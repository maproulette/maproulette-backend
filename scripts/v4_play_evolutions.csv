32	0caa39643c3fecae5590f458ec3fb5ed809f8560	2020-03-26 16:20:48.82	"-- Add dispute columns to user_metrics

ALTER TABLE '"user_metrics'" ADD COLUMN total_disputed_as_mapper integer DEFAULT 0;;
ALTER TABLE '"user_metrics'" ADD COLUMN total_disputed_as_reviewer integer DEFAULT 0;;

ALTER TABLE '"user_metrics_history'" ADD COLUMN total_disputed_as_mapper integer DEFAULT 0;;
ALTER TABLE '"user_metrics_history'" ADD COLUMN total_disputed_as_reviewer integer DEFAULT 0;;"	"ALTER TABLE '"user_metrics'" DROP COLUMN total_disputed_as_mapper;;
ALTER TABLE '"user_metrics'" DROP COLUMN total_disputed_as_reviewer;;

ALTER TABLE '"user_metrics_history'" DROP COLUMN total_disputed_as_mapper;;
ALTER TABLE '"user_metrics_history'" DROP COLUMN total_disputed_as_reviewer;;"	applied	""
33	e0c873dad4523872c13fe1afc812b01d37269d7d	2020-03-26 16:20:48.852	"-- Add unique constraint on task_review.task_id

ALTER TABLE '"task_review'" ADD CONSTRAINT task_review_task_id UNIQUE (task_id);;"	"ALTER TABLE '"task_review'" DROP CONSTRAINT task_review_task_id;;"	applied	""
34	5f164c42a4bc3cc48bf9ac0e3f54723ccb9c9a96	2020-03-26 16:20:48.854	"UPDATE status_actions
SET project_id = challenges.parent_id
FROM challenges
WHERE   challenge_id = challenges.id AND
challenge_id IN (select distinct challenge_id
from status_actions
INNER JOIN challenges ON challenges.id = status_actions.challenge_id
WHERE challenges.parent_id != status_actions.project_id);;"	""	applied	""
35	0d0626a1b09ed3a18c21ce5cc7eef2f353679bf2	2020-03-26 16:20:48.856	"-- Add support for virtual projectSearch
ALTER TABLE projects ADD COLUMN is_virtual boolean DEFAULT false;;

CREATE TABLE virtual_project_challenges
(
id SERIAL NOT NULL PRIMARY KEY,
project_id integer NOT NULL,
challenge_id integer NOT NULL,
created timestamp without time zone DEFAULT NOW(),

CONSTRAINT virtual_project_id_fkey FOREIGN KEY (project_id)
REFERENCES projects(id) MATCH SIMPLE
ON DELETE CASCADE,

CONSTRAINT virtual_challenge_id_fkey FOREIGN KEY (challenge_id)
REFERENCES challenges(id) MATCH SIMPLE
ON DELETE CASCADE
);;

SELECT create_index_if_not_exists(''virtual_project_challenges'', ''vp_project_id'', ''(project_id)'');;
SELECT create_index_if_not_exists(''virtual_project_challenges'', ''vp_challenge_id'', ''(challenge_id)'');;"	"ALTER TABLE projects DROP COLUMN is_virtual;;

DROP TABLE virtual_project_challenges;;"	applied	""
36	62d40a80232eee86d1b9274e7bf6ebae1525b768	2020-03-26 16:20:48.877	"-- Add timestamp to user_leaderboard

ALTER TABLE '"user_leaderboard'" ADD COLUMN created timestamp without time zone DEFAULT NOW();;"	"ALTER TABLE '"user_leaderboard'" DROP COLUMN created;;"	applied	""
37	aa3d793a4d030f1679a83d77c573ce1c9fd7314c	2020-03-26 16:20:48.884	"-- Add tag type for tags

ALTER TABLE '"tags'" ADD COLUMN tag_type character varying DEFAULT ''challenges'';;

SELECT create_index_if_not_exists(''tags'', ''tags_tag_type'', ''(tag_type)'');;
SELECT create_index_if_not_exists(''tags'', ''tags_tag_type_name'', ''(tag_type, name)'');;

UPDATE tags set tag_type = ''challenges'';;"	"ALTER TABLE '"tags'" DROP COLUMN tag_type;;"	applied	""
38	a9ab19a8c8ede518c8feb45cdf7ef2487caff640	2020-03-26 16:20:48.9	"-- Remove unique constraint on name for tags and make it a unique constraint
-- for name/tag_type

DROP INDEX '"idx_tags_name'";;

CREATE UNIQUE INDEX '"idx_tags_name_tag_type'" ON '"tags'" (lower('"name'"), '"tag_type'");;"	"DROP INDEX '"idx_tags_name_tag_type'";;

SELECT create_index_if_not_exists(''tags'', ''name'', ''(lower(name))'', true);;"	applied	""
51	9a14da4ed10573fcf461316c57b17e8718bfc06f	2020-03-26 16:20:48.999	"-- New table for bundles
CREATE TABLE IF NOT EXISTS completion_snapshots
(
id SERIAL NOT NULL PRIMARY KEY,
type_id integer NOT NULL,
item_id integer NOT NULL,
created timestamp without time zone DEFAULT NOW(),
priority integer,
available integer NOT NULL,
fixed integer NOT NULL,
false_positive integer NOT NULL,
skipped integer NOT NULL,
deleted integer NOT NULL,
already_fixed integer NOT NULL,
too_hard integer NOT NULL,
answered integer NOT NULL,
validated integer NOT NULL,
disabled integer NOT NULL
);;

-- New table for bundles
CREATE TABLE IF NOT EXISTS review_snapshots
(
id SERIAL NOT NULL PRIMARY KEY,
type_id integer NOT NULL,
item_id integer NOT NULL,
created timestamp without time zone DEFAULT NOW(),
requested integer NOT NULL,
approved integer NOT NULL,
rejected integer NOT NULL,
assisted integer NOT NULL,
disputed integer NOT NULL
);;

-- New table for task bundles
CREATE TABLE IF NOT EXISTS challenge_snapshots
(
id SERIAL NOT NULL PRIMARY KEY,
challenge_id integer NOT NULL,
challenge_name text NOT NULL,
challenge_status integer,
created timestamp without time zone DEFAULT NOW(),
completion_snapshot_id integer NOT NULL,
low_completion_snapshot_id integer NOT NULL,
medium_completion_snapshot_id integer NOT NULL,
high_completion_snapshot_id integer NOT NULL,
review_snapshot_id integer NOT NULL,
manual Boolean DEFAULT TRUE,

CONSTRAINT challenge_completion_snapshot_id FOREIGN KEY (completion_snapshot_id)
REFERENCES completion_snapshots(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT challenge_low_completion_snapshot_id FOREIGN KEY (low_completion_snapshot_id)
REFERENCES completion_snapshots(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT challenge_medium_completion_snapshot_id FOREIGN KEY (medium_completion_snapshot_id)
REFERENCES completion_snapshots(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT challenge_high_completion_snapshot_id FOREIGN KEY (high_completion_snapshot_id)
REFERENCES completion_snapshots(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT challenge_review_snapshot_id FOREIGN KEY (review_snapshot_id)
REFERENCES review_snapshots(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;

SELECT create_index_if_not_exists(''challenge_snapshots'', ''cs_challenge_id'', ''(challenge_id)'');;
SELECT create_index_if_not_exists(''challenge_snapshots'', ''cs_challenge_id_created'', ''(challenge_id, created)'');;
SELECT create_index_if_not_exists(''completion_snapshots'', ''cs_item_id_type_id'', ''(item_id, type_id)'');;
SELECT create_index_if_not_exists(''completion_snapshots'', ''cs_item_id_type_id_created'', ''(item_id, type_id, created)'');;
SELECT create_index_if_not_exists(''completion_snapshots'', ''cs_priority'', ''(priority)'');;"	"DROP TABLE IF EXISTS challenge_snapshots;;
DROP TABLE IF EXISTS completion_snapshots;;
DROP TABLE IF EXISTS review_snapshots;;"	applied	""
1	091c82312629be6406f84d51a298489872a8f582	2020-03-26 16:20:47.664	"-- Function that simply creates an index if it doesn''t already exist
CREATE OR REPLACE FUNCTION create_index_if_not_exists(t_name text, i_name text, index_sql text, unq boolean default false) RETURNS void as $$
DECLARE
full_index_name varchar;;
schema_name varchar;;
unqValue varchar;;
BEGIN
full_index_name = ''idx_'' || t_name || ''_'' || i_name;;
schema_name = ''public'';;
unqValue = '''';;
IF unq THEN
unqValue = ''UNIQUE '';;
END IF;;

IF NOT EXISTS (
SELECT 1
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname = full_index_name
AND n.nspname = schema_name
) THEN
execute ''CREATE '' || unqValue || ''INDEX '' || full_index_name || '' ON '' || schema_name || ''.'' || t_name || '' '' || index_sql;;
END IF;;
END
$$
LANGUAGE plpgsql VOLATILE;;

-- Function that is used by a trigger to updated the modified column in the table
CREATE OR REPLACE FUNCTION update_modified() RETURNS TRIGGER AS $$
BEGIN
NEW.modified = NOW();;
RETURN NEW;;
END
$$
LANGUAGE plpgsql VOLATILE;;

-- Function to remove locks when a user is deleted
CREATE OR REPLACE FUNCTION on_user_delete() RETURNS TRIGGER AS $$
BEGIN
DELETE FROM user_groups WHERE osm_user_id = old.osm_id;;
DELETE FROM locked WHERE user_id = old.id;;
RETURN old;;
END
$$
LANGUAGE plpgsql VOLATILE;;

-- MapRoulette uses postgis extension for all it''s geometries
CREATE EXTENSION IF NOT EXISTS postgis;;
-- MapRoulette uses hstore for the properties of all it''s geometries
CREATE EXTENSION IF NOT EXISTS HSTORE;;

-- The user table contains all users that have logged into MapRoulette.
CREATE TABLE IF NOT EXISTS users
(
id SERIAL NOT NULL PRIMARY KEY,
osm_id integer NOT NULL UNIQUE,
created timestamp without time zone DEFAULT NOW(),
modified timestamp without time zone DEFAULT NOW(),
osm_created timestamp without time zone NOT NULL,
name character varying NOT NULL,
description character varying,
avatar_url character varying,
api_key character varying UNIQUE,
oauth_token character varying NOT NULL,
oauth_secret character varying NOT NULL,
theme character varying DEFAULT(''skin-blue'')
);;

DROP TRIGGER IF EXISTS on_user_delete ON users;;
CREATE TRIGGER on_user_delete BEFORE DELETE ON users
FOR EACH ROW EXECUTE PROCEDURE on_user_delete();;

DO $$
BEGIN
PERFORM column_name FROM information_schema.columns WHERE table_name = ''users'' AND column_name = ''home_location'';;
IF NOT FOUND THEN
PERFORM AddGeometryColumn(''users'', ''home_location'', 4326, ''POINT'', 2);;
END IF;;
END $$;;

DROP TRIGGER IF EXISTS update_users_modified ON users;;
CREATE TRIGGER update_users_modified BEFORE UPDATE ON users
FOR EACH ROW EXECUTE PROCEDURE update_modified();;

-- Top level object that contains all challenges and surveys
CREATE TABLE IF NOT EXISTS projects
(
id SERIAL NOT NULL PRIMARY KEY,
created timestamp without time zone DEFAULT NOW(),
modified timestamp without time zone DEFAULT NOW(),
name character varying NOT NULL,
description character varying DEFAULT '''',
enabled BOOLEAN DEFAULT(true)
);;

SELECT create_index_if_not_exists(''projects'', ''name'', ''(lower(name))'', true);;

DROP TRIGGER IF EXISTS update_projects_modified ON projects;;
CREATE TRIGGER update_projects_modified BEFORE UPDATE ON projects
FOR EACH ROW EXECUTE PROCEDURE update_modified();;

-- Groups for user role management
CREATE TABLE IF NOT EXISTS groups
(
id SERIAL NOT NULL PRIMARY KEY,
project_id integer NOT NULL,
name character varying NOT NULL,
group_type integer NOT NULL,
CONSTRAINT groups_project_id_fkey FOREIGN KEY (project_id)
REFERENCES projects(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
DEFERRABLE INITIALLY DEFERRED
);;

SELECT create_index_if_not_exists(''groups'', ''name'', ''(lower(name))'', true);;

-- Table to map users to groups
CREATE TABLE IF NOT EXISTS user_groups
(
id SERIAL NOT NULL PRIMARY KEY,
osm_user_id integer NOT NULL,
group_id integer NOT NULL,
CONSTRAINT ug_user_id_fkey FOREIGN KEY (osm_user_id)
REFERENCES users(osm_id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
DEFERRABLE INITIALLY DEFERRED,
CONSTRAINT ug_group_id_fkey FOREIGN KEY (group_id)
REFERENCES groups(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;

SELECT create_index_if_not_exists(''user_groups'', ''osm_user_id_group_id'', ''(osm_user_id, group_id)'', true);;

-- Table for all challenges, which is a child of Project, Surveys are also stored in this table
CREATE TABLE IF NOT EXISTS challenges
(
id SERIAL NOT NULL PRIMARY KEY,
created timestamp without time zone DEFAULT NOW(),
modified timestamp without time zone DEFAULT NOW(),
name character varying NOT NULL,
parent_id integer NOT NULL,
description character varying DEFAULT '''',
blurb character varying DEFAULT '''',
instruction character varying DEFAULT '''',
difficulty integer DEFAULT 1,
enabled BOOLEAN DEFAULT(true),
challenge_type integer NOT NULL DEFAULT(1),
featured BOOLEAN DEFAULT(false),
overpass_ql character varying DEFAULT '''',
remote_geo_json CHARACTER VARYING DEFAULT '''',
status integer DEFAULT 0,
CONSTRAINT challenges_parent_id_fkey FOREIGN KEY (parent_id)
REFERENCES projects(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;

DROP TRIGGER IF EXISTS update_challenges_modified ON challenges;;
CREATE TRIGGER update_challenges_modified BEFORE UPDATE ON challenges
FOR EACH ROW EXECUTE PROCEDURE update_modified();;

SELECT create_index_if_not_exists(''challenges'', ''parent_id'', ''(parent_id)'');;
SELECT create_index_if_not_exists(''challenges'', ''parent_id_name'', ''(parent_id, lower(name))'', true);;

-- All the answers for a specific survey
CREATE TABLE IF NOT EXISTS answers
(
id SERIAL NOT NULL PRIMARY KEY,
created timestamp without time zone DEFAULT NOW(),
modified timestamp without time zone DEFAULT NOW(),
survey_id integer NOT NULL,
answer character varying NOT NULL,
CONSTRAINT answers_survey_id_fkey FOREIGN KEY (survey_id)
REFERENCES challenges(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
DEFERRABLE INITIALLY DEFERRED
);;

DROP TRIGGER IF EXISTS update_answers_modified ON answers;;
CREATE TRIGGER update_answers_modified BEFORE UPDATE ON answers
FOR EACH ROW EXECUTE PROCEDURE update_modified();;

SELECT create_index_if_not_exists(''answers'', ''survey_id'', ''(survey_id)'');;

-- All the tasks for a specific challenge or survey
CREATE TABLE IF NOT EXISTS tasks
(
id SERIAL NOT NULL PRIMARY KEY,
created timestamp without time zone DEFAULT NOW(),
modified timestamp without time zone DEFAULT NOW(),
name character varying NOT NULL,
instruction character varying NOT NULL,
parent_id integer NOT NULL,
status integer DEFAULT 0 NOT NULL,
CONSTRAINT tasks_parent_id_fkey FOREIGN KEY (parent_id)
REFERENCES challenges(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;

DROP TRIGGER IF EXISTS update_tasks_modified ON tasks;;
CREATE TRIGGER update_tasks_modified BEFORE UPDATE ON tasks
FOR EACH ROW EXECUTE PROCEDURE update_modified();;

DO $$
BEGIN
PERFORM column_name FROM information_schema.columns WHERE table_name = ''tasks'' AND column_name = ''location'';;
IF NOT FOUND THEN
PERFORM AddGeometryColumn(''tasks'', ''location'', 4326, ''POINT'', 2);;
END IF;;
END$$;;

SELECT create_index_if_not_exists(''tasks'', ''parent_id'', ''(parent_id)'');;
SELECT create_index_if_not_exists(''tasks'', ''parent_id_name'', ''(parent_id, lower(name))'', true);;

-- The answers for a survey from a user
CREATE TABLE IF NOT EXISTS survey_answers
(
id SERIAL NOT NULL PRIMARY KEY,
created timestamp without time zone DEFAULT NOW(),
osm_user_id integer NOT NULL,
project_id integer NOT NULL,
survey_id integer NOT NULL,
task_id integer NOT NULL,
answer_id integer NOT NULL,
CONSTRAINT survey_answers_project_id_fkey FOREIGN KEY (project_id)
REFERENCES projects(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT survey_answers_survey_id_fkey FOREIGN KEY (survey_id)
REFERENCES challenges(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT survey_answers_task_id_fkey FOREIGN KEY (task_id)
REFERENCES tasks(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT survey_answers_answer_id_fkey FOREIGN KEY (answer_id)
REFERENCES answers(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;

SELECT create_index_if_not_exists(''survey_answers'', ''survey_id'', ''(survey_id)'');;

-- The tags that can be applied to a task
CREATE TABLE IF NOT EXISTS tags
(
id SERIAL NOT NULL PRIMARY KEY,
created timestamp without time zone DEFAULT NOW(),
name character varying NOT NULL,
description character varying DEFAULT ''''
);;
-- index has the potentially to slow down inserts badly
SELECT create_index_if_not_exists(''tags'', ''name'', ''(lower(name))'', true);;

-- The tags associated with challenges
CREATE TABLE IF NOT EXISTS tags_on_challenges
(
id SERIAL NOT NULL PRIMARY KEY,
challenge_id INTEGER NOT NULL,
tag_id INTEGER NOT NULL,
CONSTRAINT challenges_tags_on_challenges_id_fkey FOREIGN KEY (challenge_id)
REFERENCES challenges (id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT tags_tags_on_challenges_id_fkey FOREIGN KEY (tag_id)
REFERENCES tags (id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;

SELECT create_index_if_not_exists(''tags_on_challenges'', ''challenge_id'', ''(challenge_id)'');;
SELECT create_index_if_not_exists(''tags_on_challenges'', ''tag_id'', ''(tag_id)'');;
-- This index could slow down inserts pretty badly
SELECT create_index_if_not_exists(''tags_on_challenges'', ''challenge_id_tag_id'', ''(challenge_id, tag_id)'');;

-- The tags associated with a task
CREATE TABLE IF NOT EXISTS tags_on_tasks
(
id SERIAL NOT NULL PRIMARY KEY,
task_id integer NOT NULL,
tag_id integer NOT NULL,
CONSTRAINT tasks_tags_on_tasks_task_id_fkey FOREIGN KEY (task_id)
REFERENCES tasks (id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT tags_tags_on_tasks_tag_id_fkey FOREIGN KEY (tag_id)
REFERENCES tags (id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;

SELECT create_index_if_not_exists(''tags_on_tasks'', ''task_id'', ''(task_id)'');;
SELECT create_index_if_not_exists(''tags_on_tasks'', ''tag_id'', ''(tag_id)'');;
-- This index could slow down inserts pretty badly
SELECT create_index_if_not_exists(''tags_on_tasks'', ''task_id_tag_id'', ''(task_id, tag_id)'');;

-- Geometries for a specific task
CREATE TABLE IF NOT EXISTS task_geometries
(
id SERIAL NOT NULL PRIMARY KEY,
task_id integer NOT NULL,
properties HSTORE,
CONSTRAINT task_geometries_task_id_fkey FOREIGN KEY (task_id)
REFERENCES tasks (id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
DEFERRABLE INITIALLY DEFERRED
);;

DO $$
BEGIN
PERFORM column_name FROM information_schema.columns WHERE table_name = ''task_geometries'' AND column_name = ''geom'';;
IF NOT FOUND THEN
PERFORM AddGeometryColumn(''task_geometries'', ''geom'', 4326, ''GEOMETRY'', 2);;
END IF;;
END$$;;

CREATE INDEX IF NOT EXISTS idx_task_geometries_geom ON task_geometries USING GIST (geom);;
SELECT create_index_if_not_exists(''task_geometries'', ''task_id'', ''(task_id)'');;

-- Actions that are taken in the system, like set the status of a task to ''fixed''
CREATE TABLE IF NOT EXISTS actions
(
id serial NOT NULL PRIMARY KEY,
created timestamp without time zone DEFAULT NOW(),
osm_user_id integer,
type_id integer,
item_id integer,
action integer NOT NULL,
status integer NOT NULL,
extra character varying
);;

SELECT create_index_if_not_exists(''actions'', ''item_id'', ''(item_id)'');;
SELECT create_index_if_not_exists(''actions'', ''osm_user_id'', ''(osm_user_id)'');;
SELECT create_index_if_not_exists(''actions'', ''created'', ''(created)'');;

-- This contains only the actions related to setting the status of a task
CREATE TABLE IF NOT EXISTS status_actions
(
id serial NOT NULL PRIMARY KEY,
created timestamp without time zone DEFAULT NOW(),
osm_user_id integer NOT NULL,
project_id integer NOT NULL,
challenge_id integer NOT NULL,
task_id integer NOT NULL,
old_status integer NOT NULL,
status integer NOT NULL,
CONSTRAINT status_actions_project_id_fkey FOREIGN KEY (project_id)
REFERENCES projects(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT status_actions_challenge_id_fkey FOREIGN KEY (challenge_id)
REFERENCES challenges(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT status_actions_task_id_fkey FOREIGN KEY (task_id)
REFERENCES tasks(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;

SELECT create_index_if_not_exists(''status_actions'', ''challenge_id'', ''(challenge_id)'');;
SELECT create_index_if_not_exists(''status_actions'', ''challenge_id_status'', ''(challenge_id,status)'');;

-- Table handling locks for any of the objects
CREATE TABLE IF NOT EXISTS locked
(
id serial NOT NULL PRIMARY KEY,
locked_time timestamp without time zone DEFAULT NOW(),
item_type integer NOT NULL,
item_id integer NOT NULL,
user_id integer NOT NULL,
CONSTRAINT locked_users_user_id FOREIGN KEY (user_id)
REFERENCES users(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;

SELECT create_index_if_not_exists(''locked'', ''item_type_item_id'', ''(item_type, item_id)'', true);;

-- Creates or updates and task. Will also check if task status needs to be updated
CREATE OR REPLACE FUNCTION create_update_task(task_name text, task_parent_id bigint, task_instruction text, task_status integer, task_id bigint DEFAULT -1, reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
return_id integer;;
BEGIN
return_id := task_id;;
IF (SELECT task_id) = -1 THEN
BEGIN
INSERT INTO tasks (name, parent_id, instruction) VALUES (task_name, task_parent_id, task_instruction) RETURNING id INTO return_id;;
EXCEPTION WHEN UNIQUE_VIOLATION THEN
SELECT INTO return_id update_task(task_name, task_parent_id, task_instruction, task_status, task_id, reset_interval);;
END;;
ELSE
PERFORM update_task(task_name, task_parent_id, task_instruction, task_status, task_id, reset_interval);;
END IF;;
RETURN return_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

CREATE OR REPLACE FUNCTION update_task(task_name text, task_parent_id bigint, task_instruction text, task_status integer, task_id bigint DEFAULT -1, reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status WHERE id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

-- Insert the default root, used for migration and those using the old API
INSERT INTO projects (id, name, description)
SELECT 0, ''SuperRootProject'', ''Root Project for super users.'' WHERE NOT EXISTS (
SELECT id FROM projects WHERE id = 0
);;
INSERT INTO groups (id, project_id, name, group_type)
SELECT -999, 0, ''SUPERUSERS'', -1 WHERE NOT EXISTS (
SELECT id FROM groups WHERE id = -999
);;
INSERT INTO users(id, osm_id, osm_created, name, oauth_token, oauth_secret, theme)
SELECT -999, -999, NOW(), ''SuperUser'', '''', '''', 0 WHERE NOT EXISTS (
SELECT id FROM users WHERE id = -999
);;
INSERT INTO user_groups (osm_user_id, group_id)
SELECT -999, -999 WHERE NOT EXISTS (
SELECT id FROM user_groups WHERE osm_user_id = -999 AND group_id = -999
);;"	"DROP TABLE IF EXISTS users CASCADE;;
DROP TABLE IF EXISTS projects CASCADE;;
DROP TABLE IF EXISTS groups CASCADE;;
DROP TABLE IF EXISTS user_groups CASCADE;;
DROP TABLE IF EXISTS challenges CASCADE;;
DROP TABLE IF EXISTS answers CASCADE;;
DROP TABLE IF EXISTS tasks CASCADE;;
DROP TABLE IF EXISTS survey_answers CASCADE;;
DROP TABLE IF EXISTS tags CASCADE;;
DROP TABLE IF EXISTS tags_on_challenges CASCADE;;
DROP TABLE IF EXISTS tags_on_tasks CASCADE;;
DROP TABLE IF EXISTS task_geometries CASCADE;;
DROP TABLE IF EXISTS actions CASCADE;;
DROP TABLE IF EXISTS status_actions CASCADE;;
DROP TABLE IF EXISTS locked CASCADE;;
DROP FUNCTION IF EXISTS create_update_task(task_name text, task_parent_id bigint, task_instruction text, task_status integer, task_id bigint, reset_interval text);;
DROP FUNCTION IF EXISTS update_task(task_name text, task_parent_id bigint, task_instruction text, task_status integer, task_id bigint, reset_interval text);;
DROP FUNCTION IF EXISTS create_index_if_not_exists(t_name text, i_name text, index_sql text, unq boolean);;
DROP FUNCTION IF EXISTS update_modified();;
DROP FUNCTION IF EXISTS on_user_delete();;"	applied	""
2	f7ab133b5975c51f15fa87d5f92cbbfae20ae8dc	2020-03-26 16:20:47.9	"-- Helper function to add/drop columns safely
CREATE OR REPLACE FUNCTION add_drop_column(tablename varchar, colname varchar, coltype varchar, addcolumn boolean default true) RETURNS varchar AS $$
DECLARE
col_name varchar;;
BEGIN
EXECUTE ''SELECT column_name FROM information_schema.columns WHERE table_name ='' || quote_literal(tablename) || '' and column_name = '' || quote_literal(colname) into col_name;;
RAISE INFO '' the val : % '', col_name;;
IF (col_name IS NULL AND addcolumn) THEN
EXECUTE ''ALTER TABLE IF EXISTS '' || tablename || '' ADD COLUMN '' || colname || '' '' || coltype;;
ELSEIF (col_name IS NOT NULL AND NOT addcolumn) THEN
EXECUTE ''ALTER TABLE IF EXISTS '' || tablename || '' DROP COLUMN '' || colname;;
END IF;;
RETURN col_name;;
END
$$
LANGUAGE plpgsql VOLATILE;;

-- adding new column for task to set it in priority 1 (HIGH), 2 (MEDIUM) or 3 (LOW), defaults to 1
SELECT add_drop_column(''tasks'', ''priority'', ''integer DEFAULT 0'');;
-- enabled defaults to false now
ALTER TABLE IF EXISTS projects ALTER COLUMN enabled SET DEFAULT false;;
ALTER TABLE IF EXISTS challenges ALTER COLUMN enabled SET DEFAULT false;;
-- New options for challenges
SELECT add_drop_column(''challenges'', ''default_priority'', ''integer DEFAULT 0'');;
SELECT add_drop_column(''challenges'', ''high_priority_rule'', ''character varying'');;
SELECT add_drop_column(''challenges'', ''medium_priority_rule'', ''character varying'');;
SELECT add_drop_column(''challenges'', ''low_priority_rule'', ''character varying'');;
SELECT add_drop_column(''challenges'', ''extra_options'', ''HSTORE'');;

-- DROP the old create_update_task function
DROP FUNCTION IF EXISTS create_update_task(text,bigint,text,integer,bigint,text);;
-- Creates or updates and task. Will also check if task status needs to be updated
-- This change simply adds the priority
CREATE OR REPLACE FUNCTION create_update_task(task_name text, task_parent_id bigint, task_instruction text, task_status integer, task_id bigint DEFAULT -1, task_priority integer DEFAULT 0, reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
return_id integer;;
BEGIN
return_id := task_id;;
IF (SELECT task_id) = -1 THEN
BEGIN
INSERT INTO tasks (name, parent_id, instruction, priority) VALUES (task_name, task_parent_id, task_instruction, task_priority) RETURNING id INTO return_id;;
EXCEPTION WHEN UNIQUE_VIOLATION THEN
SELECT INTO return_id update_task(task_name, task_parent_id, task_instruction, task_status, task_id, task_priority, reset_interval);;
END;;
ELSE
PERFORM update_task(task_name, task_parent_id, task_instruction, task_status, task_id, task_priority, reset_interval);;
END IF;;
RETURN return_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

DROP FUNCTION IF EXISTS update_task(text,bigint,text,integer,bigint,text);;
CREATE OR REPLACE FUNCTION update_task(task_name text, task_parent_id bigint, task_instruction text, task_status integer, task_id bigint DEFAULT -1, task_priority integer DEFAULT 0, reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority WHERE id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	"SELECT add_drop_column(''tasks'', ''priority'', '''', false);;
ALTER TABLE IF EXISTS projects ALTER COLUMN enabled SET DEFAULT true;;
ALTER TABLE IF EXISTS challenges ALTER COLUMN enabled SET DEFAULT true;;
SELECT add_drop_column(''challenges'', ''default_priority'', '''', false);;
SELECT add_drop_column(''challenges'', ''high_priority_rule'', '''', false);;
SELECT add_drop_column(''challenges'', ''medium_priority_rule'', '''', false);;
SELECT add_drop_column(''challenges'', ''low_priority_rule'', '''', false);;
SELECT add_drop_column(''challenges'', ''extra_options'', '''', false);;
DROP FUNCTION IF EXISTS add_drop_column(varchar,varchar,varchar,boolean);;

-- Creates or updates and task. Will also check if task status needs to be updated
DROP FUNCTION IF EXISTS create_update_task(text,bigint,text,integer,bigint,integer,text);;
CREATE OR REPLACE FUNCTION create_update_task(task_name text, task_parent_id bigint, task_instruction text, task_status integer, task_id bigint DEFAULT -1, reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
return_id integer;;
BEGIN
return_id := task_id;;
IF (SELECT task_id) = -1 THEN
BEGIN
INSERT INTO tasks (name, parent_id, instruction) VALUES (task_name, task_parent_id, task_instruction) RETURNING id INTO return_id;;
EXCEPTION WHEN UNIQUE_VIOLATION THEN
SELECT INTO return_id update_task(task_name, task_parent_id, task_instruction, task_status, task_id, reset_interval);;
END;;
ELSE
PERFORM update_task(task_name, task_parent_id, task_instruction, task_status, task_id, reset_interval);;
END IF;;
RETURN return_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

DROP FUNCTION IF EXISTS update_task(text,bigint,text,integer,bigint,integer,text);;
CREATE OR REPLACE FUNCTION update_task(task_name text, task_parent_id bigint, task_instruction text, task_status integer, task_id bigint DEFAULT -1, reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status WHERE id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	applied	""
3	274658974eeff3c3f1e97b7f1c2fba013360706c	2020-03-26 16:20:47.953	"DO $$
BEGIN
PERFORM column_name FROM information_schema.columns WHERE table_name = ''challenges'' AND column_name = ''location'';;
IF NOT FOUND THEN
PERFORM AddGeometryColumn(''challenges'', ''location'', 4326, ''POINT'', 2);;
END IF;;
END$$;;

-- Updating all the locations for all the tasks in the system. This process takes about 2 minutes or
-- so depending on the amount of tasks and geometries in the system
DO $$
DECLARE
rec RECORD;;
BEGIN
FOR rec IN SELECT task_id, ST_Centroid(ST_Collect(ST_Makevalid(geom))) AS location
FROM task_geometries tg
GROUP BY task_id LOOP
UPDATE tasks SET location = rec.location WHERE tasks.id = rec.task_id;;
END LOOP;;
END$$;;

-- Update all the challenge locations based on the locations of their respective tasks. This process
-- is fairly quick due to the update of the tasks in the previous statement
DO $$
DECLARE
rec RECORD;;
BEGIN
FOR rec IN SELECT id FROM challenges LOOP
UPDATE challenges SET location = (SELECT ST_Centroid(ST_Collect(ST_Makevalid(location)))
FROM tasks
WHERE parent_id = rec.id)
WHERE id = rec.id;;
END LOOP;;
END$$;;


-- Modifying this function so that if you send in the default status it ignores it and updates it with the current status of the task.
-- This is done primarily because the only way that a existing task should have be reset to the default status (CREATED) is if the
-- task is being uploaded as part of a scheduled upload and it is past the set time that defines that this task should be rechecked
CREATE OR REPLACE FUNCTION update_task(task_name text, task_parent_id bigint, task_instruction text, task_status integer, task_id bigint DEFAULT -1, task_priority integer DEFAULT 0, reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
IF task_status = 0 THEN
task_status = update_status;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority WHERE id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	"DO $$
BEGIN
PERFORM column_name FROM information_schema.columns WHERE table_name = ''challenges'' AND column_name = ''location'';;
IF FOUND THEN
PERFORM DropGeometryColumn(''challenges'', ''location'');;
END IF;;
END$$;;

DROP FUNCTION IF EXISTS update_task(text,bigint,text,integer,bigint,integer,text);;
CREATE OR REPLACE FUNCTION update_task(task_name text, task_parent_id bigint, task_instruction text, task_status integer, task_id bigint DEFAULT -1, task_priority integer DEFAULT 0, reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority WHERE id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	applied	""
4	7568411ca73a4e7a613646728b0420fb57aef22a	2020-03-26 16:20:47.965	"-- Updating index so that we can''t create duplicate tags with tasks or challenges
DROP INDEX IF EXISTS idx_tags_on_tasks_task_id_tag_id;;
SELECT create_index_if_not_exists(''tags_on_tasks'', ''task_id_tag_id'', ''(task_id, tag_id)'', true);;
DROP INDEX IF EXISTS idx_tags_on_challenges_challenge_id_tag_id;;
SELECT create_index_if_not_exists(''tags_on_challenges'', ''challenge_id_tag_id'', ''(challenge_id, tag_id)'', true);;"	"DROP INDEX IF EXISTS idx_tags_on_tasks_task_id_tag_id;;
SELECT create_index_if_not_exists(''tags_on_tasks'', ''task_id_tag_id'', ''(task_id, tag_id)'');;
DROP INDEX IF EXISTS idx_tags_on_challenges_challenge_id_tag_id;;
SELECT create_index_if_not_exists(''tags_on_challenges'', ''challenge_id_tag_id'', ''(challenge_id, tag_id)'');;"	applied	""
5	4cd646dae60e02d2786c7cf315178967a158e424	2020-03-26 16:20:47.973	"-- Update users table for user settings
SELECT add_drop_column(''users'', ''default_editor'', ''integer DEFAULT -1'');;
SELECT add_drop_column(''users'', ''default_basemap'', ''integer DEFAULT -1'');;
SELECT add_drop_column(''users'', ''custom_basemap_url'', ''character varying'');;
SELECT add_drop_column(''users'', ''email_opt_in'', ''boolean DEFAULT false'');;
SELECT add_drop_column(''users'', ''locale'', ''character varying'');;
SELECT add_drop_column(''users'', ''theme'', '''', false);;
SELECT add_drop_column(''users'', ''theme'', ''integer DEFAULT -1'');;

SELECT add_drop_column(''challenges'', ''default_zoom'', ''integer DEFAULT 13'');;
SELECT add_drop_column(''challenges'', ''min_zoom'', ''integer DEFAULT 1'');;
SELECT add_drop_column(''challenges'', ''max_zoom'', ''integer DEFAULT 19'');;
SELECT add_drop_column(''challenges'', ''default_basemap'', ''integer'');;
SELECT add_drop_column(''challenges'', ''custom_basemap'', ''character varying'');;

-- Table for all challenges, which is a child of Project, Surveys are also stored in this table
CREATE TABLE IF NOT EXISTS saved_challenges
(
id SERIAL NOT NULL PRIMARY KEY,
created timestamp without time zone DEFAULT NOW(),
user_id integer NOT NULL,
challenge_id integer NOT NULL,
CONSTRAINT saved_challenges_user_id FOREIGN KEY (user_id)
REFERENCES users(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT saved_challenges_challenge_id FOREIGN KEY (challenge_id)
REFERENCES challenges(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;
SELECT create_index_if_not_exists(''saved_challenges'', ''user_id'', ''(user_id)'');;
SELECT create_index_if_not_exists(''saved_challenges'', ''user_id_challenge_id'', ''(user_id, challenge_id)'', true);;"	"SELECT add_drop_column(''users'', ''default_editor'', '''', false);;
SELECT add_drop_column(''users'', ''default_basemap'', '''', false);;
SELECT add_drop_column(''users'', ''custom_basemap_url'', '''', false);;
SELECT add_drop_column(''users'', ''email_opt_in'', '''', false);;
SELECT add_drop_column(''users'', ''locale'', '''', false);;
SELECT add_drop_column(''users'', ''theme'', '''', false);;
SELECT add_drop_column(''users'', ''theme'', ''character varying DEFAULT(''''skin-blue'''')'');;

SELECT add_drop_column(''challenges'', ''default_zoom'', '''', false);;
SELECT add_drop_column(''challenges'', ''min_zoom'', '''', false);;
SELECT add_drop_column(''challenges'', ''max_zoom'', '''', false);;
SELECT add_drop_column(''challenges'', ''default_basemap'', '''', false);;
SELECT add_drop_column(''challenges'', ''custom_basemap'', '''', false);;

DROP TABLE IF EXISTS saved_challenges;;"	applied	""
6	995c32e6c58dcc1dfe18ade9d6a34f0c9e93214c	2020-03-26 16:20:48.13	"-- Index for cleanOldTasks job
SELECT create_index_if_not_exists(''tasks'', ''status_modified'', ''(status, modified)'');;"	DROP INDEX IF EXISTS idx_tasks_status_modified;;	applied	""
7	6f20b08beb9f26b7c7325a38538ce293c7f10915	2020-03-26 16:20:48.133	"-- Column to keep track of whether old tasks in the challenge should be
SELECT add_drop_column(''challenges'', ''updateTasks'', ''BOOLEAN DEFAULT(false)'');;"	SELECT add_drop_column('challenges', 'updateTasks', '', false);;	applied	""
8	571463fcb61b4382be27677aaaab0416e77e16f7	2020-03-26 16:20:48.15	"-- Column to keep track of whether old tasks in the challenge should be
SELECT add_drop_column(''challenges'', ''owner_id'', ''integer NOT NULL DEFAULT -1'');;"	SELECT add_drop_column('challenges', 'owner_id', '', false);;	applied	""
44	11a7726885cfdb7c48fcce50699cd8cfadcffbcc	2020-03-26 16:20:48.969	"ALTER TABLE challenges ADD COLUMN data_origin_date timestamp without time zone;;

UPDATE challenges set data_origin_date = last_task_refresh;;"	ALTER TABLE challenges DROP COLUMN data_origin_date;;	applied	""
52	8db9c6dd66c5c0075c76c8183a1918a565a0cdda	2020-03-26 16:20:49.026	"-- Add preferred_tags to challenges.
ALTER TABLE IF EXISTS challenges ADD COLUMN preferred_tags VARCHAR;;"	ALTER TABLE IF EXISTS challenges DROP COLUMN preferred_tags;;	applied	""
9	c32e2e8098b02b7c09a1991595547cd96d3ee81f	2020-03-26 16:20:48.169	"-- Column to keep track of whether old tasks in the challenge should be
SELECT add_drop_column(''challenges'', ''last_updated'', ''timestamp without time zone DEFAULT NOW()'');;
-- Add new Column to Challenge to allow users to define the checkin comments for Challenges
SELECT add_drop_column(''challenges'', ''checkin_comment'', ''character varying'');;
UPDATE challenges SET checkin_comment = ''#maproulette #'' || replace(name, '' '', ''_'');;

CREATE TABLE IF NOT EXISTS task_comments
(
id SERIAL NOT NULL PRIMARY KEY,
osm_id integer NOT NULL,
task_id integer NOT NULL,
created timestamp without time zone DEFAULT NOW(),
comment character varying,
action_id integer null,
CONSTRAINT task_comments_tasks_id_fkey FOREIGN KEY (task_id)
REFERENCES tasks (id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT task_comments_actions_id_fkey FOREIGN KEY (action_id)
REFERENCES actions (id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE SET NULL
);;

-- update all the last updated values
DO $$
DECLARE
rec RECORD;;
BEGIN
FOR rec IN SELECT id FROM challenges LOOP
UPDATE challenges SET last_updated = (SELECT MAX(modified)
FROM tasks
WHERE parent_id = rec.id)
WHERE id = rec.id;;
END LOOP;;
END$$;;
UPDATE challenges SET last_updated = NOW() WHERE last_updated IS NULL;;"	"SELECT add_drop_column(''challenges'', ''last_updated'', '''', false);;
SELECT add_drop_column(''challenges'', ''checkin_comment'', '''', false);;
DROP TABLE IF EXISTS task_comments;;"	applied	""
10	47ab02bbe5759cf5eefc885859ebb08fd74264db	2020-03-26 16:20:48.204	"-- Add default Challenge for default Survey Answers
INSERT INTO challenges (id, name, parent_id, challenge_type) VALUES (-1, ''Default Dummy Survey'', 0, 2);;
-- Add default Valid (-1) and InValid (-2) answers for any Challenge
INSERT INTO answers (id, survey_id, answer) VALUES
(-1, -1, ''Valid''),
(-2, -1, ''Invalid'');;"	"DELETE FROM challenges WHERE id = -1;;
DELETE FROM answers WHERE id IN (-1, -2);;"	applied	""
11	6ca62ddaf09aab1087bf318d77c39c096e10eb0f	2020-03-26 16:20:48.208	"-- Add display name column for projects
SELECT add_drop_column(''projects'', ''display_name'', ''character varying NULL'');;
SELECT add_drop_column(''projects'', ''owner_id'', ''integer NOT NULL DEFAULT -999'');;
ALTER TABLE projects
ADD CONSTRAINT projects_owner_id_fkey FOREIGN KEY (owner_id)
REFERENCES users(osm_id) MATCH SIMPLE
ON DELETE SET DEFAULT;;

ALTER TABLE ONLY challenges ALTER COLUMN owner_id SET DEFAULT -999;;
UPDATE challenges SET owner_id = -999 WHERE owner_id = -1;;
ALTER TABLE challenges
ADD CONSTRAINT challenges_owner_id_fkey FOREIGN KEY (owner_id)
REFERENCES users(osm_id) MATCH SIMPLE
ON DELETE SET DEFAULT;;

-- update all display name columns to be the name of the user followed by the project
-- Also update the owner_id to be the actual owner of the project
DO $$
DECLARE
rec RECORD;;
owner INT;;
display VARCHAR;;
BEGIN
FOR rec IN SELECT id, name FROM projects LOOP
SELECT NULL INTO display;;
SELECT NULL INTO owner;;
IF rec.name LIKE ''Home_%'' THEN
SELECT osm_id FROM users WHERE osm_id = (SELECT REPLACE(rec.name, ''Home_'', '''')::INT) INTO owner;;
SELECT name || ''''''s Project'' FROM users WHERE osm_id = owner INTO display;;
ELSE
SELECT owner_id FROM challenges WHERE parent_id = rec.id LIMIT 1 INTO owner;;
END IF;;
IF owner IS NULL THEN
SELECT -999 INTO owner;;
END IF;;
IF display IS NULL THEN
SELECT rec.name INTO display;;
END IF;;
UPDATE projects SET
owner_id = owner,
display_name = display
WHERE id = rec.id;;
END LOOP;;
END$$;;


-- Add new bounding box that captures the bounding box for all the tasks within the current challenge
DO $$
BEGIN
PERFORM column_name FROM information_schema.columns WHERE table_name = ''challenges'' AND column_name = ''bounding'';;
IF NOT FOUND THEN
PERFORM AddGeometryColumn(''challenges'', ''bounding'', 4326, ''POLYGON'', 2);;
END IF;;
END$$;;
-- Add spatial index for challenge location
CREATE INDEX IF NOT EXISTS idx_challenges_location ON challenges USING GIST (location);;
-- Add spatial index for challenge bounding box
CREATE INDEX IF NOT EXISTS idx_challenges_bounding ON challenges USING GIST (bounding);;

-- Table for all challenges, which is a child of Project, Surveys are also stored in this table
CREATE TABLE IF NOT EXISTS saved_tasks
(
id SERIAL NOT NULL PRIMARY KEY,
created timestamp without time zone DEFAULT NOW(),
user_id integer NOT NULL,
task_id integer NOT NULL,
challenge_id integer NOT NULL,
CONSTRAINT saved_tasks_user_id FOREIGN KEY (user_id)
REFERENCES users(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT saved_tasks_task_id FOREIGN KEY (task_id)
REFERENCES tasks(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT saved_tasks_challenge_id FOREIGN KEY (challenge_id)
REFERENCES challenges(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;
SELECT create_index_if_not_exists(''saved_tasks'', ''user_id'', ''(user_id)'');;
SELECT create_index_if_not_exists(''saved_tasks'', ''user_id_task_id'', ''(user_id, task_id)'', true);;
SELECT create_index_if_not_exists(''saved_tasks'', ''user_id_challenge_id'', ''(user_id, challenge_id)'');;

-- Create trigger on the tasks that if anything changes it updates the challenge modified date
-- Function that is used by a trigger to updated the modified column in the table
CREATE OR REPLACE FUNCTION update_tasks() RETURNS TRIGGER AS $$
DECLARE
task RECORD;;
BEGIN
IF TG_OP=''DELETE'' THEN
task = OLD;;
ELSE
NEW.modified = NOW();;
task = NEW;;
END IF;;
UPDATE challenges SET modified = NOW() WHERE id = task.parent_id;;
RETURN task;;
END
$$
LANGUAGE plpgsql VOLATILE;;
DROP TRIGGER IF EXISTS update_tasks_modified ON tasks;;
DROP TRIGGER IF EXISTS update_tasks_trigger ON tasks;;
CREATE TRIGGER update_tasks_trigger BEFORE UPDATE OR INSERT OR DELETE ON tasks
FOR EACH ROW EXECUTE PROCEDURE update_tasks();;

-- Update the bounding box for all challenges
DO $$
DECLARE
rec RECORD;;
BEGIN
FOR rec IN SELECT id FROM challenges LOOP
BEGIN
UPDATE challenges SET bounding = (SELECT ST_Envelope(ST_Buffer((ST_SetSRID(ST_Extent(location), 4326))::geography,2)::geometry)
FROM tasks
WHERE parent_id = rec.id)
WHERE id = rec.id;;
EXCEPTION WHEN SQLSTATE ''XX000'' THEN
RAISE NOTICE ''Failed to create bounding for challenge %'', rec.id;;
END;;
END LOOP;;
END$$;;"	"SELECT add_drop_column(''projects'', ''display_name'', '''', false);;
SELECT add_drop_column(''projects'', ''owner_id'', '''', false);;
ALTER TABLE projects DROP CONSTRAINT IF EXISTS projects_owner_id_fkey;;
ALTER TABLE challenges DROP COLUMN bounding;;
DROP TABLE saved_tasks;;
DROP TRIGGER IF EXISTS update_tasks_trigger ON tasks;;
DROP FUNCTION update_tasks();;
CREATE TRIGGER update_tasks_modified BEFORE UPDATE ON tasks
FOR EACH ROW EXECUTE PROCEDURE update_modified();;"	applied	""
12	e19d1570bfd0e45f769573e8c1eb8bf686345032	2020-03-26 16:20:48.259	"-- New table for virtual challenges
CREATE TABLE IF NOT EXISTS virtual_challenges
(
id SERIAL NOT NULL PRIMARY KEY,
owner_id integer NOT NULL,
name character varying NULL,
created timestamp without time zone DEFAULT NOW(),
modified timestamp without time zone DEFAULT NOW(),
description character varying NULL,
search_parameters character varying NOT NULL,
expiry timestamp with time zone DEFAULT NOW() + INTERVAL ''1 day''
);;

SELECT create_index_if_not_exists(''virtual_challenges'', ''owner_id'', ''(owner_id)'');;

CREATE TABLE IF NOT EXISTS virtual_challenge_tasks
(
id SERIAL NOT NULL PRIMARY KEY,
task_id integer NOT NULL,
virtual_challenge_id integer NOT NULL,
CONSTRAINT virtual_challenges_tasks_task_id_fkey FOREIGN KEY (task_id)
REFERENCES tasks(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT virtual_challenges_tasks_virtual_challenge_id_fkey FOREIGN KEY (virtual_challenge_id)
REFERENCES virtual_challenges(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;

SELECT create_index_if_not_exists(''virtual_challenge_tasks'', ''virtual_challenge_id'', ''(virtual_challenge_id)'');;"	"DROP TABLE virtual_challenge_tasks;;
DROP TABLE virtual_challenges;;"	applied	""
13	cd1e02ee9dbe4912d380da6f8e149f2e3f49820b	2020-03-26 16:20:48.274	"SELECT add_drop_column(''users'', ''properties'', ''character varying'');;
SELECT create_index_if_not_exists(''status_actions'', ''osm_user_id_created'', ''(osm_user_id,created)'');;
-- Add changeset_id column
SELECT add_drop_column(''tasks'', ''changeset_id'', ''integer DEFAULT -1'');;
SELECT add_drop_column(''challenges'', ''info_link'', ''character varying'');;

-- Add deleted columns for challenges and projects
SELECT add_drop_column(''challenges'', ''deleted'', ''boolean default false'');;
SELECT add_drop_column(''projects'', ''deleted'', ''boolean default false'');;

-- Add trigger function that will set challenges to deleted if the project is deleted
CREATE OR REPLACE FUNCTION on_project_delete_update() RETURNS TRIGGER AS $$
BEGIN
IF new.deleted = true AND old.deleted = false THEN
UPDATE challenges SET deleted = true WHERE parent_id = new.id;;
ELSEIF new.deleted = false AND old.deleted = true THEN
UPDATE challenges SET deleted = false WHERE parent_id = new.id;;
END IF;;
RETURN new;;
END
$$
LANGUAGE plpgsql VOLATILE;;

DROP TRIGGER IF EXISTS on_project_update_delete ON projects;;
CREATE TRIGGER on_project_update_delete AFTER UPDATE ON projects
FOR EACH ROW EXECUTE PROCEDURE on_project_delete_update();;

-- Creates or updates and task. Will also check if task status needs to be updated
-- This change simply adds the priority
CREATE OR REPLACE FUNCTION create_update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
return_id integer;;
BEGIN
return_id := task_id;;
IF (SELECT task_id) = -1 THEN
BEGIN
INSERT INTO tasks (name, parent_id, instruction,  priority) VALUES (task_name, task_parent_id, task_instruction, task_priority) RETURNING id INTO return_id;;
EXCEPTION WHEN UNIQUE_VIOLATION THEN
SELECT INTO return_id update_task(task_name, task_parent_id, task_instruction, task_status, task_id, task_priority, task_changeset_id, reset_interval);;
END;;
ELSE
PERFORM update_task(task_name, task_parent_id, task_instruction, task_status, task_id, task_priority, task_changeset_id, reset_interval);;
END IF;;
RETURN return_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

CREATE OR REPLACE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority, changeset_id = task_changeset_id WHERE id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

-- Add constraint that doesn''t allow the same user to create a virtual challenge with the same name
ALTER TABLE virtual_challenges DROP CONSTRAINT IF EXISTS CON_VIRTUAL_CHALLENGES_USER_ID_NAME;;
ALTER TABLE virtual_challenges ADD CONSTRAINT CON_VIRTUAL_CHALLENGES_USER_ID_NAME
UNIQUE (owner_id, name);;"	"SELECT add_drop_column(''users'', ''properties'', '''', false);;
DROP INDEX IF EXISTS idx_status_actions_osm_user_id_created;;
SELECT add_drop_column(''tasks'', ''changeset_id'', '''', false);;
SELECT add_drop_column(''challenges'', ''info_link'', '''', false);;
SELECT add_drop_column(''challenges'', ''deleted'', '''', false);;
SELECT add_drop_column(''projects'', ''deleted'', '''', false);;
DROP TRIGGER IF EXISTS on_project_update_delete ON projects;;

-- UPDATE TASKS
DROP FUNCTION create_update_task(text,bigint,text,integer,bigint,integer,bigint,text);;
CREATE OR REPLACE FUNCTION create_update_task(task_name text, task_parent_id bigint, task_instruction text, task_status integer, task_id bigint DEFAULT -1, task_priority integer DEFAULT 0, reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
return_id integer;;
BEGIN
return_id := task_id;;
IF (SELECT task_id) = -1 THEN
BEGIN
INSERT INTO tasks (name, parent_id, instruction, priority) VALUES (task_name, task_parent_id, task_instruction, task_priority) RETURNING id INTO return_id;;
EXCEPTION WHEN UNIQUE_VIOLATION THEN
SELECT INTO return_id update_task(task_name, task_parent_id, task_instruction, task_status, task_id, task_priority, reset_interval);;
END;;
ELSE
PERFORM update_task(task_name, task_parent_id, task_instruction, task_status, task_id, task_priority, reset_interval);;
END IF;;
RETURN return_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;
DROP FUNCTION update_task(text,bigint,text,integer,bigint,integer,bigint,text);;
CREATE OR REPLACE FUNCTION update_task(task_name text, task_parent_id bigint, task_instruction text, task_status integer, task_id bigint DEFAULT -1, task_priority integer DEFAULT 0, reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
IF task_status = 0 THEN
task_status = update_status;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority WHERE id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;
---------------
ALTER TABLE virtual_challenges DROP CONSTRAINT IF EXISTS CON_VIRTUAL_CHALLENGES_USER_ID_NAME;;"	applied	""
14	14bb3e02b2d19aef55e4331a11f1dd8f09625be8	2020-03-26 16:20:48.388	"SELECT add_drop_column(''task_comments'', ''challenge_id'', ''integer NOT NULL DEFAULT -1'');;
SELECT add_drop_column(''task_comments'', ''project_id'', ''integer NOT NULL DEFAULT -1'');;
-- update current projects before adding the constraints
UPDATE task_comments SET challenge_id = (SELECT parent_id FROM tasks WHERE task_comments.task_id = id),
project_id = (SELECT c.parent_id FROM challenges c
INNER JOIN tasks t ON t.parent_id = c.id
WHERE task_comments.task_id = t.id);;

ALTER TABLE task_comments DROP CONSTRAINT IF EXISTS task_comments_challenge_id_fkey;;
ALTER TABLE task_comments ADD CONSTRAINT task_comments_challenge_id_fkey
FOREIGN KEY (challenge_id) REFERENCES challenges (id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE;;
ALTER TABLE task_comments DROP CONSTRAINT IF EXISTS task_comments_project_id_fkey;;
ALTER TABLE task_comments ADD CONSTRAINT task_comments_project_id_fkey
FOREIGN KEY (project_id) REFERENCES projects (id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE;;

-- Add status failure text
SELECT add_drop_column(''challenges'', ''status_message'', ''text NULL'');;"	"SELECT add_drop_column(''task_comments'', ''challenge_id'', '''', false);;
SELECT add_drop_column(''task_comments'', ''project_id'', '''', false);;
ALTER TABLE task_comments DROP CONSTRAINT IF EXISTS task_comments_challenge_id_fkey;;
ALTER TABLE task_comments DROP CONSTRAINT IF EXISTS task_comments_project_id_fkey;;
SELECT add_drop_column(''challenges'', ''status_message'', '''', false);;"	applied	""
15	91b3b50ffe050e420c188701c2208620af0ee46e	2020-03-26 16:20:48.471	"-- Add trigger function that will automatically update project and challenge ID''s in the task_comments table
CREATE OR REPLACE FUNCTION on_task_comment_insert() RETURNS TRIGGER AS $$
BEGIN
IF new.challenge_id IS NULL OR new.challenge_id = -1 THEN
new.challenge_id := (SELECT parent_id FROM tasks WHERE id = new.task_id);;
END IF;;
IF new.project_id IS NULL OR new.project_id = -1 THEN
new.project_id := (SELECT parent_id FROM challenges WHERE id = new.challenge_id);;
END IF;;
RETURN new;;
END
$$
LANGUAGE plpgsql VOLATILE;;

DROP TRIGGER IF EXISTS on_task_comment_insert ON task_comments;;
CREATE TRIGGER on_task_comment_insert BEFORE INSERT ON task_comments
FOR EACH ROW EXECUTE PROCEDURE on_task_comment_insert();;"	DROP TRIGGER IF EXISTS on_task_comment_insert ON task_comments;;	applied	""
16	713f2d8a560fec4bef99113c4aef2e29b2ad92f6	2020-03-26 16:20:48.473	"-- Add leaderboard_opt_out column to users table
SELECT add_drop_column(''users'', ''leaderboard_opt_out'', ''boolean DEFAULT FALSE'');;"	SELECT add_drop_column('users', 'leaderboard_opt_out', '', false);;	applied	""
17	ede3e9497f7520862d0edd319e84e2812b75b69d	2020-03-26 16:20:48.516	"-- We need to reset all the API Keys
UPDATE users SET api_key = null;;"	""	applied	""
18	311d1eb193e580b610d72dff594da63d121fb01f	2020-03-26 16:20:48.519	"-- Add checkin_source column to challenges table
SELECT add_drop_column(''challenges'', ''checkin_source'', ''character varying'');;"	SELECT add_drop_column('challenges', 'checkin_source', '', false);;	applied	""
19	795d767521d21c33b4c9b00fda8a278710d0aecc	2020-03-26 16:20:48.526	"-- Remove unique index on Groups
DROP INDEX IF EXISTS idx_groups_name;;
SELECT create_index_if_not_exists(''groups'', ''project_id_group_type'', ''(project_id, group_type)'');;"	"DROP INDEX IF EXISTS idx_groups_project_id_group_type;;
-- previously the index was a unique index, but due to changes the database would be invalid and we wouldn''t be able to create a unique index at this point
SELECT create_index_if_not_exists(''groups'', ''name'', ''(lower(name))'');;"	applied	""
20	4263e17e1cc8c52e1140d92485c765c75ae484ab	2020-03-26 16:20:48.538	"-- Add default_basemap_id column to challenges and users tables
SELECT add_drop_column(''challenges'', ''default_basemap_id'', ''character varying'');;
SELECT add_drop_column(''users'', ''default_basemap_id'', ''character varying'');;"	"SELECT add_drop_column(''challenges'', ''default_basemap_id'', '''', false);;
SELECT add_drop_column(''users'', ''default_basemap_id'', '''', false);;"	applied	""
21	3b541b768ffd60d708c1afdfd75b531e6699af36	2020-03-26 16:20:48.552	"-- Add last_task_refresh column to challenges table
ALTER TABLE '"challenges'" ADD COLUMN last_task_refresh TIMESTAMP WITH TIME ZONE;;
UPDATE challenges c SET last_task_refresh=created WHERE last_task_refresh IS NULL AND 0 < (SELECT COUNT(*) FROM tasks t WHERE t.parent_id = c.id LIMIT 1);;"	"ALTER TABLE '"challenges'" DROP COLUMN last_task_refresh;;"	applied	""
45	964c1b91e1a3531dfa585327e0505ba33b581ec1	2020-03-26 16:20:48.972	"-- Update all challenges to STATUS_FINISHED (5) that have at least 1 task and
-- have no tasks in CREATED (0) or SKIPPED (3) statuses
--
-- Update all challenges to STATUS_READY (3) that were set to STATUS_FINISHED
-- but still have at least one task in CREATED (0) or SKIPPED (3) status
UPDATE challenges c SET status=5 WHERE
0 < (SELECT COUNT(*) FROM tasks where tasks.parent_id=c.id) AND
0 = (SELECT COUNT(*) AS total FROM tasks
WHERE tasks.parent_id=c.id AND status IN (0, 3));;

UPDATE challenges c SET status=3 WHERE
c.status = 5 AND
0 < (SELECT COUNT(*) AS total FROM tasks
WHERE tasks.parent_id=c.id AND status IN (0, 3));;"	""	applied	""
22	3687d4d847f8a65c3f01db0b1ae72297116c223e	2020-03-26 16:20:48.554	"-- Add popularity column to challenges
ALTER TABLE '"challenges'" ADD COLUMN popularity INT DEFAULT FLOOR(EXTRACT(epoch from NOW()));;

-- Calculate initial popularity scores
-- Very basic scoring for popularity p: p = (p + t) / 2 where t is timestamp
-- Initial score set to created timestamp of challenge
UPDATE challenges SET popularity=FLOOR(EXTRACT(epoch from created));;

DO $$ DECLARE completion_action RECORD;;
BEGIN
FOR completion_action IN SELECT challenge_id, FLOOR(EXTRACT(epoch FROM created)) AS createdts FROM status_actions
WHERE old_status != status AND status > 0 AND status < 8 ORDER BY created ASC
LOOP
UPDATE challenges SET popularity = ((popularity + completion_action.createdts) / 2)
WHERE id = completion_action.challenge_id;;
END LOOP;;
END$$;;

SELECT create_index_if_not_exists(''challenges'', ''popularity'', ''(popularity)'');;"	"ALTER TABLE '"challenges'" DROP COLUMN popularity;;"	applied	""
23	f14e19a96d55ebd275d0a991870d0676e0668052	2020-03-26 16:20:48.586	"-- Updates all challenges to a STATUS_FINISHED that have no incomplete tasks
UPDATE challenges c SET status=5 WHERE c.status=3 AND
0=(SELECT COUNT(*) AS total FROM tasks
WHERE tasks.parent_id=c.id AND status=0);;"	""	applied	""
24	10995edc2c27aa12297b7e2001a45d7527ce07f2	2020-03-26 16:20:48.59	"-- New table for virtual challenges
CREATE TABLE IF NOT EXISTS user_leaderboard
(
month_duration integer NOT NULL,
user_id integer NOT NULL,
user_name character varying NULL,
user_avatar_url character varying NULL,
user_ranking integer NOT NULL,
user_score integer NOT NULL
);;

CREATE TABLE IF NOT EXISTS user_top_challenges
(
month_duration integer NOT NULL,
user_id integer NOT NULL,
challenge_id integer NOT NULL,
challenge_name character varying NULL,
activity integer NOT NULL
);;"	"DROP TABLE IF EXISTS user_leaderboard;;
DROP TABLE IF EXISTS user_top_challenges;;"	applied	""
25	5553bf5b79d774d02843d85b883fe0beeb896988	2020-03-26 16:20:48.599	"-- Add country_code column to user_leaderboard
ALTER TABLE '"user_leaderboard'" ADD COLUMN country_code character varying NULL;;

-- Add country_code column to user_top_challenges
ALTER TABLE '"user_top_challenges'" ADD COLUMN country_code character varying NULL;;

-- Geometries for a specific task
CREATE TABLE IF NOT EXISTS task_suggested_fix
(
id SERIAL NOT NULL PRIMARY KEY,
task_id integer NOT NULL,
properties HSTORE,
CONSTRAINT task_suggested_fix_task_id_fkey FOREIGN KEY (task_id)
REFERENCES tasks (id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
DEFERRABLE INITIALLY DEFERRED
);;

DO $$
BEGIN
PERFORM column_name FROM information_schema.columns WHERE table_name = ''task_suggested_fix'' AND column_name = ''geom'';;
IF NOT FOUND THEN
PERFORM AddGeometryColumn(''task_suggested_fix'', ''geom'', 4326, ''GEOMETRY'', 2);;
END IF;;
END$$;;

CREATE INDEX IF NOT EXISTS idx_task_geometries_geom ON task_suggested_fix USING GIST (geom);;
SELECT create_index_if_not_exists(''task_suggested_fix'', ''task_id'', ''(task_id)'');;"	"ALTER TABLE '"user_leaderboard'" DROP COLUMN country_code;;
ALTER TABLE '"user_top_challenges'" DROP COLUMN country_code;;
DROP TABLE task_suggested_fix;;"	applied	""
46	7dfd53941ea5b4a404ce836748b4501787bb4e23	2020-03-26 16:20:48.975	"-- To allow us to know how long a lock has been in existence once we allow lock
-- times to be extended, add a created column to the '"locked'" table and update
-- existing locks to match the creation timestamp with their current
-- locked_time
ALTER TABLE '"locked'" ADD COLUMN created timestamp without time zone DEFAULT NOW();;
UPDATE locked set created=locked_time;;"	"ALTER TABLE '"locked'" DROP COLUMN created;;"	applied	""
47	7fdc8cfa77f39bbe4a4c4b024e3b7173ff8ca78a	2020-03-26 16:20:48.983	"-- Add subscription option for challenge completion notifications
ALTER TABLE IF EXISTS user_notification_subscriptions ADD COLUMN challenge_completed integer NOT NULL DEFAULT 1;;"	ALTER TABLE IF EXISTS user_notification_subscriptions DROP COLUMN challenge_completed;;	applied	""
48	313b22e7601c3875b12416f54b47c6c754e16af2	2020-03-26 16:20:48.991	"-- Setup constraints on virtual_project_challenges to restrict duplicate
-- entries.

-- Find and fix prior duplicate entries.
DELETE FROM
virtual_project_challenges a
USING virtual_project_challenges b
WHERE
a.id < b.id
AND a.project_id = b.project_id
AND a.challenge_id = b.challenge_id;;

-- Add unique constraint.
CREATE UNIQUE INDEX CONCURRENTLY virtual_project_challenges_projects
ON virtual_project_challenges (project_id, challenge_id);;

ALTER TABLE virtual_project_challenges DROP CONSTRAINT
IF EXISTS unique_virtual_project_challenges_projects;;
ALTER TABLE virtual_project_challenges
ADD CONSTRAINT unique_virtual_project_challenges_projects
UNIQUE USING INDEX virtual_project_challenges_projects;;"	"ALTER TABLE virtual_project_challenges
DROP CONSTRAINT IF EXISTS unique_virtual_project_challenges;;"	applied	""
49	7d8330ddeeb9959d34b3876a902af72660965e61	2020-03-26 16:20:48.995	"-- Creates or updates and task. Will also check if task status needs to be updated
-- This change makes sure not to reset the task status if a task is disabled or declared a false positive
CREATE OR REPLACE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geo_json jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
geojson_geom geometry;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
-- only reset the status if the task is not currently disabled or set as a false positive and all other criteria is met.
IF update_status = task_status AND NOT (update_status = 9 OR update_status = 2) AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geo_json->''features'');;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on, geojson = geo_json,
suggestedfix_geojson = suggestedfix,
location = ST_Centroid(geojson_geom),
geom = geojson_geom
WHERE id = update_id;;
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	"DROP FUNCTION update_task(text,bigint,text,integer,jsonb,jsonb,bigint,integer,bigint,text,timestamp,integer,integer,integer,timestamp);;
CREATE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geo_json jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
geojson_geom geometry;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geo_json->''features'');;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on, geojson = geo_json,
suggestedfix_geojson = suggestedfix,
location = ST_Centroid(geojson_geom),
geom = geojson_geom
WHERE id = update_id;;
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	applied	""
50	242ea1d472a73bdb8b31a4a7c23b0d06e54253f4	2020-03-26 16:20:48.998	"-- Add configurable feature properties to treat as osm id
ALTER TABLE IF EXISTS challenges ADD COLUMN osm_id_property VARCHAR;;"	ALTER TABLE IF EXISTS challenges DROP COLUMN osm_id_property;;	applied	""
26	c05aa1363d1bcecebfb766cc188b2bd24caf18a7	2020-03-26 16:20:48.643	"-- New table for virtual challenges
CREATE TABLE IF NOT EXISTS user_metrics
(
user_id integer NOT NULL,
score integer NOT NULL,
total_fixed integer,
total_false_positive integer,
total_already_fixed integer,
total_too_hard integer,
total_skipped integer
);;

CREATE TABLE IF NOT EXISTS user_metrics_history
(
user_id integer NOT NULL,
score integer NOT NULL,
total_fixed integer,
total_false_positive integer,
total_already_fixed integer,
total_too_hard integer,
total_skipped integer,
snapshot_date timestamp without time zone DEFAULT NOW()
);;

SELECT create_index_if_not_exists(''user_metrics'', ''user_id'', ''(user_id)'');;
SELECT create_index_if_not_exists(''user_metrics_history'', ''user_id'', ''(user_id)'');;
SELECT create_index_if_not_exists(''user_metrics_history'', ''user_id_snapshot_date'', ''(user_id, snapshot_date)'');;

INSERT INTO user_metrics
(user_id, score, total_fixed, total_false_positive, total_already_fixed, total_too_hard, total_skipped)
SELECT users.id,
SUM(CASE sa.status
WHEN 1 THEN 5
WHEN 2 THEN 3
WHEN 5 THEN 3
WHEN 6 THEN 1
WHEN 3 THEN 0
ELSE 0
END) AS score,
SUM(CASE WHEN sa.status = 1 then 1 else 0 end) total_fixed,
SUM(CASE WHEN sa.status = 2 then 1 else 0 end) total_false_positive,
SUM(CASE WHEN sa.status = 5 then 1 else 0 end) total_already_fixed,
SUM(CASE WHEN sa.status = 6 then 1 else 0 end) total_too_hard,
SUM(CASE WHEN sa.status = 3 then 1 else 0 end) total_skipped
FROM status_actions sa, users
WHERE users.osm_id = sa.osm_user_id AND sa.old_status <> sa.status
GROUP BY sa.osm_user_id, users.id;;"	"DROP TABLE IF EXISTS user_metrics;;
DROP TABLE IF EXISTS user_metrics_history;;"	applied	""
27	3a9201842e036c6a09bf53695dd73f2487df81b5	2020-03-26 16:20:48.661	"-- Add needs_review, is_reviewer to user table
ALTER TABLE '"users'" ADD COLUMN needs_review boolean DEFAULT false;;
ALTER TABLE '"users'" ADD COLUMN is_reviewer boolean DEFAULT false;;

-- Add table to keep track of review status
CREATE TABLE IF NOT EXISTS task_review
(
id SERIAL NOT NULL PRIMARY KEY,
task_id integer NOT NULL,
review_status integer,
review_requested_by integer,
reviewed_by integer DEFAULT NULL,
reviewed_at timestamp without time zone DEFAULT NULL,
review_claimed_at timestamp without time zone DEFAULT NULL,
review_claimed_by integer DEFAULT NULL
);;


-- Add table to keep track of review history
CREATE TABLE IF NOT EXISTS task_review_history
(
id SERIAL NOT NULL PRIMARY KEY,
task_id integer NOT NULL,
requested_by integer NOT NULL,
reviewed_by integer,
review_status integer NOT NULL,
reviewed_at timestamp without time zone DEFAULT NOW()
);;

ALTER TABLE '"status_actions'" ADD COLUMN started_at timestamp without time zone DEFAULT NULL;;

SELECT create_index_if_not_exists(''task_review_history'', ''task_review_history_task_id'', ''(task_id)'');;
SELECT create_index_if_not_exists(''task_review'', ''tasks_review_id'', ''(task_id)'');;
SELECT create_index_if_not_exists(''task_review'', ''tasks_review_status'', ''(review_status)'');;
SELECT create_index_if_not_exists(''task_review'', ''tasks_reviewed_by'', ''(reviewed_by)'');;
SELECT create_index_if_not_exists(''task_review'', ''tasks_review_claimed_by'', ''(review_claimed_by)'');;
SELECT create_index_if_not_exists(''task_review'', ''tasks_review_claimed_at'', ''(review_claimed_at)'');;"	"ALTER TABLE '"users'" DROP COLUMN needs_review;;
ALTER TABLE '"users'" DROP COLUMN is_reviewer;;

ALTER TABLE '"status_actions'" DROP COLUMN started_at;;

DROP TABLE IF EXISTS task_review;;
DROP TABLE IF EXISTS task_review_history;;"	applied	""
28	c9a4759df4ed6a08131ced1302eceecfcc703d22	2020-03-26 16:20:48.739	"-- Add Mapped on timestamp
ALTER TABLE '"tasks'" ADD COLUMN mapped_on timestamp without time zone DEFAULT NULL;;

-- DROP FUNCTION create_update_task(text,bigint,text,integer,bigint,integer,bigint,text);;
-- DROP FUNCTION update_task(text,bigint,text,integer,bigint,integer,bigint,text);;

-- Creates or updates and task. Will also check if task status needs to be updated
-- This change adds the mapped_on, review_status, review_requested_by, reviewed_by
CREATE OR REPLACE FUNCTION create_update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL) RETURNS integer as $$
DECLARE
return_id integer;;
BEGIN
return_id := task_id;;
IF (SELECT task_id) = -1 THEN
BEGIN
INSERT INTO tasks (name, parent_id, instruction,  priority) VALUES (task_name, task_parent_id, task_instruction, task_priority) RETURNING id INTO return_id;;
EXCEPTION WHEN UNIQUE_VIOLATION THEN
SELECT INTO return_id update_task(task_name, task_parent_id, task_instruction, task_status, task_id, task_priority, task_changeset_id, reset_interval, task_mapped_on, task_review_status, task_review_requested_by, task_reviewed_by, task_reviewed_at);;
END;;
ELSE
PERFORM update_task(task_name, task_parent_id, task_instruction, task_status, task_id, task_priority, task_changeset_id, reset_interval, task_mapped_on, task_review_status, task_review_requested_by, task_reviewed_by, task_reviewed_at);;
END IF;;
RETURN return_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

CREATE OR REPLACE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on WHERE id = update_id;;
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	"ALTER TABLE '"tasks'" DROP COLUMN mapped_on;;

DROP FUNCTION create_update_task(text,bigint,text,integer,bigint,integer,bigint,text,timestamp,integer,integer, integer, timestamp);;
DROP FUNCTION update_task(text,bigint,text,integer,bigint,integer,bigint,text,timestamp,integer,integer, integer, timestamp);;

-- Creates or updates and task. Will also check if task status needs to be updated
-- This change simply rolls back this function
CREATE OR REPLACE FUNCTION create_update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
return_id integer;;
BEGIN
return_id := task_id;;
IF (SELECT task_id) = -1 THEN
BEGIN
INSERT INTO tasks (name, parent_id, instruction,  priority) VALUES (task_name, task_parent_id, task_instruction, task_priority) RETURNING id INTO return_id;;
EXCEPTION WHEN UNIQUE_VIOLATION THEN
SELECT INTO return_id update_task(task_name, task_parent_id, task_instruction, task_status, task_id, task_priority, task_changeset_id, reset_interval);;
END;;
ELSE
PERFORM update_task(task_name, task_parent_id, task_instruction, task_status, task_id, task_priority, task_changeset_id, reset_interval);;
END IF;;
RETURN return_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

CREATE OR REPLACE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'') RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority, changeset_id = task_changeset_id WHERE id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	applied	""
29	986c7af08d0551139a68621a643db6abde84da77	2020-03-26 16:20:48.743	"-- Add needs_review, is_reviewer to user table
ALTER TABLE '"user_metrics'" ADD COLUMN initial_rejected integer DEFAULT 0;;
ALTER TABLE '"user_metrics'" ADD COLUMN initial_approved integer DEFAULT 0;;
ALTER TABLE '"user_metrics'" ADD COLUMN initial_assisted integer DEFAULT 0;;
ALTER TABLE '"user_metrics'" ADD COLUMN total_rejected integer DEFAULT 0;;
ALTER TABLE '"user_metrics'" ADD COLUMN total_approved integer DEFAULT 0;;
ALTER TABLE '"user_metrics'" ADD COLUMN total_assisted integer DEFAULT 0;;

ALTER TABLE '"user_metrics_history'" ADD COLUMN initial_rejected integer DEFAULT 0;;
ALTER TABLE '"user_metrics_history'" ADD COLUMN initial_approved integer DEFAULT 0;;
ALTER TABLE '"user_metrics_history'" ADD COLUMN initial_assisted integer DEFAULT 0;;
ALTER TABLE '"user_metrics_history'" ADD COLUMN total_rejected integer DEFAULT 0;;
ALTER TABLE '"user_metrics_history'" ADD COLUMN total_approved integer DEFAULT 0;;
ALTER TABLE '"user_metrics_history'" ADD COLUMN total_assisted integer DEFAULT 0;;

ALTER TABLE '"user_metrics'" ADD CONSTRAINT user_metric_primary_key PRIMARY KEY (user_id);;

-- This fixes bug where new users since the original creation of user_metrics where not having
-- their score tallied.
INSERT INTO user_metrics
(user_id, score, total_fixed, total_false_positive, total_already_fixed, total_too_hard, total_skipped)
SELECT users.id,
SUM(CASE sa.status
WHEN 1 THEN 5
WHEN 2 THEN 3
WHEN 5 THEN 3
WHEN 6 THEN 1
WHEN 3 THEN 0
ELSE 0
END) AS score,
SUM(CASE WHEN sa.status = 1 then 1 else 0 end) total_fixed,
SUM(CASE WHEN sa.status = 2 then 1 else 0 end) total_false_positive,
SUM(CASE WHEN sa.status = 5 then 1 else 0 end) total_already_fixed,
SUM(CASE WHEN sa.status = 6 then 1 else 0 end) total_too_hard,
SUM(CASE WHEN sa.status = 3 then 1 else 0 end) total_skipped
FROM status_actions sa, users
WHERE users.osm_id = sa.osm_user_id AND sa.old_status <> sa.status
AND users.id NOT IN (select user_id from user_metrics)
GROUP BY sa.osm_user_id, users.id;;"	"ALTER TABLE '"user_metrics'" DROP COLUMN initial_rejected;;
ALTER TABLE '"user_metrics'" DROP COLUMN initial_approved;;
ALTER TABLE '"user_metrics'" DROP COLUMN initial_assisted;;
ALTER TABLE '"user_metrics'" DROP COLUMN total_rejected;;
ALTER TABLE '"user_metrics'" DROP COLUMN total_approved;;
ALTER TABLE '"user_metrics'" DROP COLUMN total_assisted;;

ALTER TABLE '"user_metrics_history'" DROP COLUMN initial_rejected;;
ALTER TABLE '"user_metrics_history'" DROP COLUMN initial_approved;;
ALTER TABLE '"user_metrics_history'" DROP COLUMN initial_assisted;;
ALTER TABLE '"user_metrics_history'" DROP COLUMN total_rejected;;
ALTER TABLE '"user_metrics_history'" DROP COLUMN total_approved;;
ALTER TABLE '"user_metrics_history'" DROP COLUMN total_assisted;;

ALTER TABLE '"user_metrics'" DROP CONSTRAINT user_metric_primary_key"	applied	""
30	6e12d9877410e57b3755a2c83e8efc5eb477acd3	2020-03-26 16:20:48.793	"-- Add email address to users table
ALTER TABLE '"users'" ADD COLUMN email character varying;;

-- New table for notifications
CREATE TABLE IF NOT EXISTS user_notifications
(
id SERIAL NOT NULL PRIMARY KEY,
user_id integer NOT NULL,
notification_type integer NOT NULL,
created timestamp without time zone DEFAULT NOW(),
modified timestamp without time zone DEFAULT NOW(),
description character varying,
from_username character varying,
is_read boolean DEFAULT FALSE,
email_status integer NOT NULL,
task_id integer,
challenge_id integer,
project_id integer,
target_id integer,
extra character varying
);;

SELECT create_index_if_not_exists(''user_notifications'', ''user_id'', ''(user_id)'');;
SELECT create_index_if_not_exists(''user_notifications'', ''email_status'', ''(email_status)'');;

-- New table for notification subscriptions
CREATE TABLE IF NOT EXISTS user_notification_subscriptions
(
id SERIAL NOT NULL PRIMARY KEY,
user_id integer NOT NULL,
system integer NOT NULL DEFAULT 1,
mention integer NOT NULL DEFAULT 1,
review_approved integer NOT NULL DEFAULT 1,
review_rejected integer NOT NULL DEFAULT 1,
review_again integer NOT NULL DEFAULT 1
);;

SELECT create_index_if_not_exists(''user_notification_subscriptions'', ''user_id'', ''(user_id)'', true);;"	"DROP TABLE IF EXISTS user_notification_subscriptions;;
DROP TABLE IF EXISTS user_notifications;;
ALTER TABLE '"users'" DROP COLUMN email;;"	applied	""
31	ebf938f3dfb94b3f4816af590647a348d6efa4c9	2020-03-26 16:20:48.806	"-- Change users.needs_review to be an integer type so we can have more
-- variability with this setting.

ALTER TABLE users ALTER COLUMN needs_review SET DEFAULT null;;

ALTER TABLE users ALTER COLUMN needs_review TYPE INTEGER USING
CASE
WHEN needs_review = true then 1
WHEN needs_review = false then 0
ELSE NULL
END;;"	"ALTER TABLE users ALTER COLUMN needs_review TYPE BOOLEAN USING
CASE
WHEN needs_review = 1 then true
WHEN needs_review = 2 then true
ELSE false
END;;

ALTER TABLE users ALTER COLUMN needs_review SET DEFAULT false;;"	applied	""
39	49f35da1115152a4f4990777e98c0221c1cfe6b0	2020-03-26 16:20:48.905	"-- THESE COMMENTED SCRIPTS NEED TO BE RUN BEFORE UPGRADING -------------------------------
-- Add new geojson and geometries into the task table, migrate all the task geometry data to the task table and then drop the task_geometry table
DO $$
BEGIN
PERFORM column_name FROM information_schema.columns WHERE table_name = ''tasks'' AND column_name = ''geojson'';;
IF NOT FOUND THEN
ALTER TABLE tasks ADD COLUMN geojson JSONB;;
END IF;;
END$$;;
DO $$
BEGIN
PERFORM column_name FROM information_schema.columns WHERE table_name = ''tasks'' AND column_name = ''geom'';;
IF NOT FOUND THEN
PERFORM AddGeometryColumn(''tasks'', ''geom'', 4326, ''GEOMETRY'', 2);;
END IF;;
END$$;;
DO $$
BEGIN
PERFORM column_name FROM information_schema.columns WHERE table_name = ''tasks'' AND column_name = ''suggestedfix_geojson'';;
IF NOT FOUND THEN
ALTER TABLE tasks ADD COLUMN suggestedfix_geojson JSONB;;
END IF;;
END$$;;

-- Migrate all the old geometries to the new structure
-- update the geojson columns -- SEE 39_upgrade.py python script
-- THIS PYTHON SCRIPT MUST BE RUN BEFORE UPGRADING
--DO $$
--    DECLARE identifier integer;;
--BEGIN
--    FOR identifier IN SELECT id FROM tasks LOOP
--        UPDATE tasks t SET geojson = geoms.geometries FROM (SELECT ROW_TO_JSON(fc)::JSONB AS geometries
--                      FROM ( SELECT ''FeatureCollection'' AS type, ARRAY_TO_JSON(array_agg(f)) AS features
--                               FROM ( SELECT ''Feature'' AS type,
--                                              ST_AsGeoJSON(lg.geom)::JSONB AS geometry,
--                                              HSTORE_TO_JSON(lg.properties) AS properties
--                                      FROM task_geometries AS lg
--                                      WHERE task_id = identifier
--                                ) AS f
--                        )  AS fc) AS geoms WHERE id = identifier;;
--        -- Update the geometry and location columns
--        UPDATE tasks t SET geom = geoms.geometry, location = ST_CENTROID(geoms.geometry)
--        FROM (SELECT ST_COLLECT(ST_MAKEVALID(geom)) AS geometry FROM (
--                SELECT geom FROM task_geometries WHERE task_id = identifier
--             ) AS innerQuery) AS geoms WHERE id = identifier;;
--    END LOOP;;
--END$$;;

-- update the geojson columns for suggested fixes
--DO $$
--	  DECLARE id integer;;
--	  DECLARE c integer;;
--BEGIN
--	  FOR id IN SELECT t.id FROM tasks t INNER JOIN task_suggested_fix tf ON t.id = tf.task_id LOOP
--        UPDATE tasks t SET suggestedfix_geojson = geoms.geometries FROM (SELECT ROW_TO_JSON(fc)::JSONB AS geometries
--              FROM ( SELECT ''FeatureCollection'' AS type, ARRAY_TO_JSON(array_agg(f)) AS features
--                       FROM ( SELECT ''Feature'' AS type,
--                                      ST_AsGeoJSON(lg.geom)::JSONB AS geometry,
--                                      HSTORE_TO_JSON(lg.properties) AS properties
--                              FROM task_suggested_fix AS lg
--                              WHERE task_id = id
--                        ) AS f
--                )  AS fc) AS geoms;;
--    END LOOP;;
--END$$;;

--DROP TABLE task_geometries CASCADE;;
--DROP TABLE task_suggested_fix CASCADE;;
----------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION update_challenge_geometry(challenge_identifier bigint)
RETURNS VOID AS $$
DECLARE
identifier BIGINT;;
BEGIN
FOR identifier IN SELECT id FROM tasks WHERE parent_id = challenge_identifier AND geojson IS NULL LOOP
PERFORM update_geometry(identifier);;
END LOOP;;
END
$$ LANGUAGE plpgsql VOLATILE;;

CREATE OR REPLACE FUNCTION update_geometry(task_identifier bigint)
RETURNS TABLE(geo TEXT, loc TEXT, fix_geo TEXT) AS $$
BEGIN
UPDATE tasks t SET geojson = geoms.geometries FROM (SELECT ROW_TO_JSON(fc)::JSONB AS geometries
FROM ( SELECT ''FeatureCollection'' AS type, ARRAY_TO_JSON(array_agg(f)) AS features
FROM ( SELECT ''Feature'' AS type,
ST_AsGeoJSON(lg.geom)::JSONB AS geometry,
HSTORE_TO_JSON(lg.properties) AS properties
FROM task_geometries AS lg
WHERE task_id = task_identifier
) AS f
)  AS fc) AS geoms WHERE id = task_identifier;;
-- Update the geometry and location columns
UPDATE tasks t SET geom = geoms.geometry, location = ST_CENTROID(geoms.geometry)
FROM (SELECT ST_COLLECT(ST_MAKEVALID(geom)) AS geometry FROM (
SELECT geom FROM task_geometries WHERE task_id = task_identifier
) AS innerQuery) AS geoms WHERE id = task_identifier;;
RETURN QUERY SELECT geojson::TEXT, ST_AsGeoJSON(location) AS geo_location, suggestedfix_geojson::TEXT FROM tasks
WHERE id = task_identifier;;
END
$$ LANGUAGE plpgsql VOLATILE;;

-- Creates or updates and task. Will also check if task status needs to be updated
-- This change adds the mapped_on, review_status, review_requested_by, reviewed_by
CREATE OR REPLACE FUNCTION create_update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geojson jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL) RETURNS integer as $$
DECLARE
return_id integer;;
geojson_geom geometry;;
BEGIN
return_id := task_id;;
IF (SELECT task_id) = -1 THEN
BEGIN
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geojson->''features'');;

INSERT INTO tasks (name, parent_id, instruction, priority, geojson, location, geom, suggestedfix_geojson)
VALUES (task_name, task_parent_id, task_instruction, task_priority, geojson, ST_Centroid(geojson_geom), geojson_geom, suggestedfix) RETURNING id INTO return_id;;
EXCEPTION WHEN UNIQUE_VIOLATION THEN
SELECT INTO return_id update_task(task_name, task_parent_id, task_instruction, task_status, geojson, suggestedfix, task_id, task_priority,
task_changeset_id, reset_interval, task_mapped_on, task_review_status, task_review_requested_by, task_reviewed_by, task_reviewed_at);;
END;;
ELSE
PERFORM update_task(task_name, task_parent_id, task_instruction, task_status, geojson, suggestedfix, task_id, task_priority,
task_changeset_id, reset_interval, task_mapped_on, task_review_status, task_review_requested_by, task_reviewed_by, task_reviewed_at);;
END IF;;
RETURN return_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

CREATE OR REPLACE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geojson jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
geojson_geom geometry;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geojson->''features'');;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on, geojson = geojson,
suggestedfix_geojson = suggestedfix,
location = ST_Centroid(geojson_geom),
geom = geojson_geom
WHERE id = update_id;;
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

-- Add tag type for tags
ALTER TABLE '"task_review'" ADD COLUMN review_started_at timestamp without time zone DEFAULT NULL;;
ALTER TABLE '"task_review_history'" ADD COLUMN review_started_at timestamp without time zone DEFAULT NULL;;"	"-- The Downs in this version will not work, essentially it is not backwards compatible at this point. Once you upgrade to version 37, you cannot drop back to a previous version
DROP FUNCTION update_challenge_geometry(bigint);;
DROP FUNCTION update_geometry(bigint);;

-- Creates or updates and task. Will also check if task status needs to be updated
-- This change adds the mapped_on, review_status, review_requested_by, reviewed_by
DROP FUNCTION create_update_task(text,bigint,text,integer,jsonb,jsonb,bigint,integer,bigint,text,timestamp,integer,integer,integer,timestamp);;
CREATE OR REPLACE FUNCTION create_update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL) RETURNS integer as $$
DECLARE
return_id integer;;
BEGIN
return_id := task_id;;
IF (SELECT task_id) = -1 THEN
BEGIN
INSERT INTO tasks (name, parent_id, instruction,  priority) VALUES (task_name, task_parent_id, task_instruction, task_priority) RETURNING id INTO return_id;;
EXCEPTION WHEN UNIQUE_VIOLATION THEN
SELECT INTO return_id update_task(task_name, task_parent_id, task_instruction, task_status, task_id, task_priority, task_changeset_id, reset_interval, task_mapped_on, task_review_status, task_review_requested_by, task_reviewed_by, task_reviewed_at);;
END;;
ELSE
PERFORM update_task(task_name, task_parent_id, task_instruction, task_status, task_id, task_priority, task_changeset_id, reset_interval, task_mapped_on, task_review_status, task_review_requested_by, task_reviewed_by, task_reviewed_at);;
END IF;;
RETURN return_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

DROP FUNCTION update_task(text,bigint,text,integer,jsonb,jsonb,bigint,integer,bigint,text,timestamp,integer,integer,integer,timestamp);;
CREATE OR REPLACE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on WHERE id = update_id;;
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

ALTER TABLE '"task_review'" DROP COLUMN review_started_at;;
ALTER TABLE '"task_review_history'" DROP COLUMN review_started_at;;"	applied	""
40	0a769cf22ea7f035ed4dd99151d8fc08e31c8b0a	2020-03-26 16:20:48.929	"-- Creates or updates and task. Will also check if task status needs to be updated
-- This change adds the mapped_on, review_status, review_requested_by, reviewed_by
DROP FUNCTION IF EXISTS create_update_task(text,bigint,text,integer,jsonb,jsonb,bigint,integer,bigint,text,timestamp without time zone,integer,integer,integer,timestamp without time zone);;
CREATE FUNCTION create_update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geo_json jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL) RETURNS integer as $$
DECLARE
return_id integer;;
geojson_geom geometry;;
BEGIN
return_id := task_id;;
IF (SELECT task_id) = -1 THEN
BEGIN
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geo_json->''features'');;

INSERT INTO tasks (name, parent_id, instruction, priority, geojson, location, geom, suggestedfix_geojson)
VALUES (task_name, task_parent_id, task_instruction, task_priority, geo_json, ST_Centroid(geojson_geom), geojson_geom, suggestedfix) RETURNING id INTO return_id;;
EXCEPTION WHEN UNIQUE_VIOLATION THEN
SELECT INTO return_id update_task(task_name, task_parent_id, task_instruction, task_status, geo_json, suggestedfix, task_id, task_priority,
task_changeset_id, reset_interval, task_mapped_on, task_review_status, task_review_requested_by, task_reviewed_by, task_reviewed_at);;
END;;
ELSE
PERFORM update_task(task_name, task_parent_id, task_instruction, task_status, geo_json, suggestedfix, task_id, task_priority,
task_changeset_id, reset_interval, task_mapped_on, task_review_status, task_review_requested_by, task_reviewed_by, task_reviewed_at);;
END IF;;
RETURN return_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

DROP FUNCTION IF EXISTS update_task(text,bigint,text,integer,jsonb,jsonb,bigint,integer,bigint,text,timestamp without time zone,integer,integer,integer,timestamp without time zone);;
CREATE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geo_json jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
geojson_geom geometry;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geo_json->''features'');;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on, geojson = geo_json,
suggestedfix_geojson = suggestedfix,
location = ST_Centroid(geojson_geom),
geom = geojson_geom
WHERE id = update_id;;
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	"-- Creates or updates and task. Will also check if task status needs to be updated
-- This change adds the mapped_on, review_status, review_requested_by, reviewed_by
DROP FUNCTION create_update_task(text,bigint,text,integer,jsonb,jsonb,bigint,integer,bigint,text,timestamp,integer,integer,integer,timestamp);;
CREATE OR REPLACE FUNCTION create_update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geojson jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL) RETURNS integer as $$
DECLARE
return_id integer;;
geojson_geom geometry;;
BEGIN
return_id := task_id;;
IF (SELECT task_id) = -1 THEN
BEGIN
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geojson->''features'');;

INSERT INTO tasks (name, parent_id, instruction, priority, geojson, location, geom, suggestedfix_geojson)
VALUES (task_name, task_parent_id, task_instruction, task_priority, geojson, ST_Centroid(geojson_geom), geojson_geom, suggestedfix) RETURNING id INTO return_id;;
EXCEPTION WHEN UNIQUE_VIOLATION THEN
SELECT INTO return_id update_task(task_name, task_parent_id, task_instruction, task_status, geojson, suggestedfix, task_id, task_priority,
task_changeset_id, reset_interval, task_mapped_on, task_review_status, task_review_requested_by, task_reviewed_by, task_reviewed_at);;
END;;
ELSE
PERFORM update_task(task_name, task_parent_id, task_instruction, task_status, geojson, suggestedfix, task_id, task_priority,
task_changeset_id, reset_interval, task_mapped_on, task_review_status, task_review_requested_by, task_reviewed_by, task_reviewed_at);;
END IF;;
RETURN return_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;

DROP FUNCTION update_task(text,bigint,text,integer,jsonb,jsonb,bigint,integer,bigint,text,timestamp,integer,integer,integer,timestamp);;
CREATE OR REPLACE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geojson jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
geojson_geom geometry;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geojson->''features'');;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on, geojson = geojson,
suggestedfix_geojson = suggestedfix,
location = ST_Centroid(geojson_geom),
geom = geojson_geom
WHERE id = update_id;;
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	applied	""
41	689600de3a762ca0dda633bfdf83dcf63b3d0295	2020-03-26 16:20:48.933	"-- Add suggested_fix for tasks
ALTER TABLE challenges ADD COLUMN has_suggested_fixes boolean DEFAULT false;;"	ALTER TABLE challenges DROP COLUMN has_suggested_fixes;;	applied	""
42	d3dbaa3370546da1c990ac604c8f45395bc87ffb	2020-03-26 16:20:48.952	"-- Add completion_responses for tasks
ALTER TABLE tasks ADD COLUMN completion_responses jsonb;;
ALTER TABLE challenges ADD COLUMN exportable_properties text;;"	"ALTER TABLE tasks DROP COLUMN completion_responses;;
ALTER TABLE challenges DROP COLUMN exportable_properties;;"	applied	""
43	fafaa443c1ab00c50da57e8bee201083531af2c7	2020-03-26 16:20:48.954	"-- New table for bundles
CREATE TABLE IF NOT EXISTS bundles
(
id SERIAL NOT NULL PRIMARY KEY,
owner_id integer NOT NULL,
name character varying NULL,
description character varying NULL,
created timestamp without time zone DEFAULT NOW(),
modified timestamp without time zone DEFAULT NOW(),
CONSTRAINT bundles_owner_id FOREIGN KEY (owner_id)
REFERENCES users(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;

-- New table for task bundles
CREATE TABLE IF NOT EXISTS task_bundles
(
id SERIAL NOT NULL PRIMARY KEY,
task_id integer NOT NULL,
bundle_id integer NOT NULL,
CONSTRAINT task_bundles_task_id FOREIGN KEY (task_id)
REFERENCES tasks(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT task_bundles_bundle_id FOREIGN KEY (bundle_id)
REFERENCES bundles(id) MATCH SIMPLE
ON UPDATE CASCADE ON DELETE CASCADE
);;

ALTER TABLE tasks ADD COLUMN bundle_id integer NULL;;
ALTER TABLE tasks ADD COLUMN is_bundle_primary boolean;;

SELECT create_index_if_not_exists(''task_bundles'', ''bundle_id'', ''(bundle_id)'');;"	"ALTER TABLE tasks DROP COLUMN bundle_id;;
ALTER TABLE tasks DROP COLUMN is_bundle_primary;;

DROP TABLE IF EXISTS task_bundles;;
DROP TABLE IF EXISTS bundles;;"	applied	""
53	79c145a698960fbb1c0c806a2c1aef28d1111a8e	2020-03-26 16:20:49.027	"-- We need to cleanup some of the task_review data as there was a bug where
-- resetting tasks back to created left entries in task_review

-- Delete rows where review_status is NULL
DELETE FROM tasks
WHERE id IN (SELECT task_id FROM task_review WHERE review_status IS NULL);;

-- Delete rows in task_review that have no corresponding entries in task table
DELETE FROM task_review
WHERE task_id NOT IN (SELECT id FROM tasks WHERE task_id = tasks.id);;

-- Delete rows in task_review where the task is in the created status.
DELETE FROM task_review
WHERE task_id IN (SELECT id FROM tasks where status = 0);;

-- Add a constraint so when a task is deleted the task_review entry is as well
ALTER TABLE task_review
ADD CONSTRAINT task_task_review_cascade
FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE;;


-- Creates or updates a task. Will also check if task status needs to be updated
-- This change is for when a task is automatically updated back to a created status it
-- will also remove it''s entry in the task_review table.
CREATE OR REPLACE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geo_json jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
geojson_geom geometry;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
-- only reset the status if the task is not currently disabled or set as a false positive and all other criteria is met.
IF update_status = task_status AND NOT (update_status = 9 OR update_status = 2) AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
-- Make sure we do not have a task_review entry if this task is in the created status.
IF new_status = 0 THEN
DELETE FROM task_review WHERE task_review.task_id = update_id;;
END IF;;
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geo_json->''features'');;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on, geojson = geo_json,
suggestedfix_geojson = suggestedfix,
location = ST_Centroid(geojson_geom),
geom = geojson_geom
WHERE id = update_id;;
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	"ALTER TABLE task_review DROP CONSTRAINT task_task_review_cascade;;

DROP FUNCTION IF EXISTS update_task(text,bigint,text,integer,jsonb,jsonb,bigint,integer,bigint,text,timestamp without time zone,integer,integer,integer,timestamp without time zone);;
CREATE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geo_json jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
geojson_geom geometry;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
IF update_status = task_status AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geo_json->''features'');;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on, geojson = geo_json,
suggestedfix_geojson = suggestedfix,
location = ST_Centroid(geojson_geom),
geom = geojson_geom
WHERE id = update_id;;
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	applied	""
54	3623750e3bf88f86453bd3b7e4f10b130ff53f2e	2020-03-26 16:20:49.035	"-- Add featured column to projects
ALTER TABLE IF EXISTS projects ADD COLUMN featured BOOLEAN DEFAULT(false);;"	ALTER TABLE IF EXISTS projects DROP COLUMN featured;;	applied	""
55	2f1b256c6105e7e825aa84e257c79afe51c8a51f	2020-03-26 16:20:49.046	"-- Add task_styles to challenges.
SELECT add_drop_column(''challenges'', ''task_styles'', ''VARCHAR DEFAULT NULL'');;
-- add task_id index for status_actions, as it causes deletes to run slower.
SELECT create_index_if_not_exists(''status_actions'', ''task_id'', ''(task_id)'');;
-- Add bundle_id index for when we are updating the bundle id for a task
SELECT create_index_if_not_exists(''tasks'', ''bundle_id'', ''(bundle_id)'');;"	"SELECT add_drop_column(''challenges'', ''task_styles'', '''', false);;
DROP INDEX IF EXISTS idx_status_actions_task_id;;
DROP INDEX IF EXISTS idx_tasks_bundle_id;;"	applied	""
56	c4fdbef9347e23916d566394edcb879fe8b24287	2020-03-26 16:20:49.053	"-- Add Time Spent Columns.
SELECT add_drop_column(''tasks'', ''completed_time_spent'', ''INT DEFAULT NULL'');;
SELECT add_drop_column(''tasks'', ''completed_by'', ''INT DEFAULT NULL'');;

SELECT add_drop_column(''completion_snapshots'', ''avg_time_spent'', ''FLOAT DEFAULT 0'');;
SELECT add_drop_column(''completion_snapshots'', ''tasks_with_time'', ''INT DEFAULT 0'');;

SELECT add_drop_column(''review_snapshots'', ''total_review_time'', ''FLOAT DEFAULT 0'');;
SELECT add_drop_column(''review_snapshots'', ''tasks_with_review_time'', ''INT DEFAULT 0'');;

SELECT add_drop_column(''user_metrics'', ''total_time_spent'', ''FLOAT DEFAULT 0'');;
SELECT add_drop_column(''user_metrics'', ''tasks_with_time'', ''INT DEFAULT 0'');;

SELECT add_drop_column(''user_metrics'', ''total_review_time'', ''FLOAT DEFAULT 0'');;
SELECT add_drop_column(''user_metrics'', ''tasks_with_review_time'', ''INT DEFAULT 0'');;

SELECT add_drop_column(''user_metrics_history'', ''total_time_spent'', ''FLOAT DEFAULT 0'');;
SELECT add_drop_column(''user_metrics_history'', ''tasks_with_time'', ''INT DEFAULT 0'');;

SELECT add_drop_column(''user_metrics_history'', ''total_review_time'', ''FLOAT DEFAULT 0'');;
SELECT add_drop_column(''user_metrics_history'', ''tasks_with_review_time'', ''INT DEFAULT 0'');;

-- Populate completed_by with review_requested_by
UPDATE tasks SET completed_by = tr.review_requested_by
FROM task_review tr
WHERE tr.task_id = tasks.id AND tasks.completed_by IS NULL;"	"SELECT add_drop_column(''tasks'', ''completed_time_spent'', '''', false);;
SELECT add_drop_column(''tasks'', ''completed_by'', '''', false);;

SELECT add_drop_column(''completion_snapshots'', ''avg_time_spent'', '''', false);;
SELECT add_drop_column(''completion_snapshots'', ''tasks_with_time'', '''', false);;

SELECT add_drop_column(''review_snapshots'', ''total_review_time'', '''', false);;
SELECT add_drop_column(''review_snapshots'', ''tasks_with_review_time'', '''', false);;

SELECT add_drop_column(''user_metrics'', ''total_time_spent'', '''', false);;
SELECT add_drop_column(''user_metrics'', ''tasks_with_time'', '''', false);;

SELECT add_drop_column(''user_metrics_history'', ''total_review_time'', '''', false);;
SELECT add_drop_column(''user_metrics_history'', ''tasks_with_review_time'', '''', false);;

SELECT add_drop_column(''user_metrics_history'', ''total_time_spent'', '''', false);;
SELECT add_drop_column(''user_metrics_history'', ''tasks_with_time'', '''', false);;

SELECT add_drop_column(''user_metrics_history'', ''total_review_time'', '''', false);;
SELECT add_drop_column(''user_metrics_history'', ''tasks_with_review_time'', '''', false);;"	applied	""
57	8b5f279eb88012e90f08e496c4bf8631f5e7b841	2020-03-26 16:20:49.215	"-- We should never have a null review_status in the task_review table.
DELETE FROM task_review WHERE review_status IS NULL;;

-- Creates or updates and task. Will also check if task status needs to be updated
-- This change makes sure not to reset the task status if a task is disabled or declared a false positive
CREATE OR REPLACE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geo_json jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
geojson_geom geometry;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
-- Only if task status is not null set/update it to the new status
IF task_status IS NOT NULL THEN
new_status := task_status;;
ELSE
new_status := update_status;;
END IF;;
-- only reset the status if the task is not currently disabled or set as a false positive and all other criteria is met.
IF update_status = task_status AND NOT (update_status = 9 OR update_status = 2) AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geo_json->''features'');;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on, geojson = geo_json,
suggestedfix_geojson = suggestedfix,
location = ST_Centroid(geojson_geom),
geom = geojson_geom
WHERE id = update_id;;
--
-- Only update task_review table if we actually have a task_review_status otherwise we will
-- end up with weird empty rows. And if the new status is created we need to delete any requested review
--
IF task_review_status IS NOT NULL THEN
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
ELSE IF new_status = 0 THEN
DELETE FROM task_review WHERE task_review.task_id = update_id;;
END IF;;
END IF;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	"--
-- Revert to last version of this stored procedure
--
CREATE OR REPLACE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geo_json jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
geojson_geom geometry;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
new_status := task_status;;
-- only reset the status if the task is not currently disabled or set as a false positive and all other criteria is met.
IF update_status = task_status AND NOT (update_status = 9 OR update_status = 2) AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geo_json->''features'');;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on, geojson = geo_json,
suggestedfix_geojson = suggestedfix,
location = ST_Centroid(geojson_geom),
geom = geojson_geom
WHERE id = update_id;;
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	applied	""
58	30705a58e302e5444e77c5feb5fd9a63ab905ecd	2020-03-26 16:20:49.218	"-- Add requires_local.
SELECT add_drop_column(''challenges'', ''requires_local'', ''BOOLEAN DEFAULT FALSE'');;"	SELECT add_drop_column('challenges', 'requires_local', '', false);;	applied	""
59	daae74584c9c3385625c9c352904e36d7faa903e	2020-03-26 16:20:49.244	"-- Creates or updates and task. Will also check if task status needs to be updated
-- This change makes sure not to reset the task status if a task is disabled or declared a false positive
CREATE OR REPLACE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geo_json jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
geojson_geom geometry;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
-- Only if task status is not null set/update it to the new status
IF task_status IS NOT NULL THEN
new_status := task_status;;
ELSE
new_status := update_status;;
END IF;;
-- only reset the status if the task is not currently disabled or set as a false positive and all other criteria is met.
IF update_status = task_status AND NOT (update_status = 9 OR update_status = 2) AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geo_json->''features'');;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on, geojson = geo_json,
suggestedfix_geojson = suggestedfix,
location = ST_Centroid(geojson_geom),
geom = geojson_geom
WHERE id = update_id;;

-- Note in status actions if status has changed
-- Since only when someone with admin privileges to a challenge can call this update
-- to change the status we just set osm_user_id to -1 (thereby not impacting any user scores).
-- To determine who did the update check the actions table.
IF update_status != new_status THEN
INSERT INTO status_actions (osm_user_id, project_id, challenge_id, task_id, old_status, status)
VALUES (-1, (SELECT parent_id FROM challenges WHERE id = task_parent_id),
task_parent_id, update_id, update_status, new_status);;
END IF;;

--
-- Only update task_review table if we actually have a task_review_status otherwise we will
-- end up with weird empty rows. And if the new status is created we need to delete any requested review
--
IF task_review_status IS NOT NULL THEN
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
ELSE IF new_status = 0 THEN
DELETE FROM task_review WHERE task_review.task_id = update_id;;
END IF;;
END IF;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	"-- Creates or updates and task. Will also check if task status needs to be updated
-- This change makes sure not to reset the task status if a task is disabled or declared a false positive
CREATE OR REPLACE FUNCTION update_task(task_name text,
task_parent_id bigint,
task_instruction text,
task_status integer,
geo_json jsonb,
suggestedfix jsonb DEFAULT NULL,
task_id bigint DEFAULT -1,
task_priority integer DEFAULT 0,
task_changeset_id bigint DEFAULT -1,
reset_interval text DEFAULT ''7 days'',
task_mapped_on timestamp DEFAULT NULL,
task_review_status integer DEFAULT NULL,
task_review_requested_by integer DEFAULT NULL,
task_reviewed_by integer DEFAULT NULL,
task_reviewed_at timestamp DEFAULT NULL
) RETURNS integer as $$
DECLARE
update_id integer;;
update_modified timestamp without time zone;;
update_status integer;;
new_status integer;;
geojson_geom geometry;;
BEGIN
IF (SELECT task_id) = -1 THEN
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE name = task_name AND parent_id = task_parent_id;;
ELSE
SELECT id, modified, status INTO update_id, update_modified, update_status FROM tasks WHERE id = task_id;;
END IF;;
-- Only if task status is not null set/update it to the new status
IF task_status IS NOT NULL THEN
new_status := task_status;;
ELSE
new_status := update_status;;
END IF;;
-- only reset the status if the task is not currently disabled or set as a false positive and all other criteria is met.
IF update_status = task_status AND NOT (update_status = 9 OR update_status = 2) AND (SELECT AGE(NOW(), update_modified)) > reset_interval::INTERVAL THEN
new_status := 0;;
END IF;;
SELECT ST_COLLECT(ST_SETSRID(ST_MAKEVALID(ST_GEOMFROMGEOJSON(jsonb_array_elements_Text::JSONB->>''geometry'')), 4326)) INTO geojson_geom
FROM JSONB_ARRAY_ELEMENTS_TEXT(geo_json->''features'');;
UPDATE tasks SET name = task_name, instruction = task_instruction, status = new_status, priority = task_priority,
changeset_id = task_changeset_id, mapped_on = task_mapped_on, geojson = geo_json,
suggestedfix_geojson = suggestedfix,
location = ST_Centroid(geojson_geom),
geom = geojson_geom
WHERE id = update_id;;
--
-- Only update task_review table if we actually have a task_review_status otherwise we will
-- end up with weird empty rows. And if the new status is created we need to delete any requested review
--
IF task_review_status IS NOT NULL THEN
UPDATE task_review SET review_status = task_review_status, review_requested_by = task_review_requested_by,
reviewed_by = task_reviewed_by, reviewed_at = task_reviewed_at WHERE task_review.task_id = update_id;;
ELSE IF new_status = 0 THEN
DELETE FROM task_review WHERE task_review.task_id = update_id;;
END IF;;
END IF;;
RETURN update_id;;
END
$$
LANGUAGE plpgsql VOLATILE;;"	applied	""
